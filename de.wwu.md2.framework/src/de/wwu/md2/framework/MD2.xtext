grammar de.wwu.md2.framework.MD2 with org.eclipse.xtext.common.Terminals

generate mD2 "http://www.wwu.de/md2/framework/MD2"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


/////////////////////////////////////
/////////////////////////////////////
// Initial
/////////////////////////////////////
/////////////////////////////////////

/*
 * The MD2Model is the root element of each model.
 * It contains the package definition and model
 * layer in the layer specific type.
 */
MD2Model:
	// Each model layer has to be stored in a
	// corresponding package (see constraints)
	package = PackageDefinition
	modelLayer = MD2ModelLayer?
;

/*
 * The MD2ModelLayer can be either a View,
 * a Controller or a Model
 */
MD2ModelLayer:
	View | Controller | Model
;

/*
 * The PackageDefinition contains the
 * package name as fully qualified name.
 */
PackageDefinition:
	'package' pkgName = QUALIFIED_NAME
;


/////////////////////////////////////
/////////////////////////////////////
// View layer
/////////////////////////////////////
/////////////////////////////////////

/*
 * The root View element contains all
 * ViewElements containing to this view model.
 */
View:
	 viewElements += ViewElement+
;

/*
 * A ViewElement can be either
 * a ViewGUIElement or a style.
 */
ViewElement:
	ViewGUIElement | Style
;

/*
 * A ViewGUIElement can be either a
 * ContainerElement or a ContentElement.
 */
ViewGUIElement:
	ContainerElement | ContentElement
;


/////////////////////////////////////
// View layer => Content elements
/////////////////////////////////////

/*
 * ContentElements are all those elements of a view that donÂ´t contain any
 * nested view elements. They are basically used to present data and
 * information to the user or collect data from the user.
 */
ContentElement:
	TextInput | OptionInput | Label | Image | AutoGeneratedContentElement |
	Spacer | Button | CheckBox | Tooltip | EntitySelector
;

/*
 * A Spacer is used in a GridLayoutPane to mark an empty
 * cell or in a FlowLayoutPane to occupy some space.
 */
Spacer:
	// Hack to force the spacer to have a name attribute in the inferred model
	// the __Dummy keyword will be suppressed in auto completion and via validator
	'Spacer' {Spacer} ('(' 'number'? number = INT? ')')? | '__Dummy' name = ID
;

/*
 * TextInputs are basically used to provide the user the possibility to insert data.
 * 
 * Using the 'type' attribute the type of the input field can be be specified
 * currently supported => date, time or time stamp; if no type is set, DEFAULT is used implicitly
 * 
 * TODO add further options to support different input keyboards for e.g. numbers, emails etc.
 */
TextInput:
	'TextInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = TextInputType)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of TextInputs.
 */
enum TextInputType:
	DEFAULT = 'default' | DATE = 'date' | TIME = 'time' | DATE_TIME = 'timestamp'
;

/*
 * OptionInputs provide the user the possibility to choose one entry of a list of strings.
 */
OptionInput:
	'OptionInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		// Optional: Options may be inferred from the mapped model if its data type is an enum
		('options' (enumReference = [Enum] | '{' (enumBody = EnumBody)? '}'))?
	) '}')?
;

/*
 * The AutoGeneratedContentElement is bound to a ContentProvider and will automatically create
 * view elements to display all attributes of the related entity. It is possible to either
 * exclude attributes specified with exclude or to provide a positive list of attributes with only.
 * In each case a list of the specified attributes will be stored in filteredAttributes. Which of
 * the two options has been chosen can be determined via exclude.
 */
AutoGeneratedContentElement:
	'AutoGenerator' name = EID '{' (
		'contentProvider' contentProvider += [ContentProvider | QUALIFIED_NAME]+
			('(' ((exclude ?= 'exclude') | 'only') filteredAttributes += EntityPathDefinition+ ')')?		
	) '}'
;

/*
 * Buttons provide the user the possibility to call actions,
 * that have been bound on the onTouch event of the Button.
 * This Button specification allows different ways to set the
 * button text (directly or via text attribute).
 */
Button:
	ButtonShorthandDefinition | ButtonExtendedDefinition	
;

/*
 * This is the shorthand definition of a Button, where
 * the text will be set in brackets behind the ID
 */
ButtonShorthandDefinition returns Button:
	'Button' name = EID '(' text = STRING ')' ('{'
		('style' style = StyleAssignment)?
	'}')?
;

/*
 * This is the extended definition of a Button, where
 * the text will be set as property
 */
ButtonExtendedDefinition returns Button:
	'Button' name = EID '{' (
		'text' text = STRING &
		('style' style = StyleAssignment)?
	) '}'
;

/*
 * CheckBoxes allow the user set boolean values.
 * A predefined status of the CheckBox can be set.
 */
CheckBox:
	'CheckBox' name = EID '{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('checked' ((checked ?= 'true') | 'false'))?
	) '}'
;

/*
 * Tooltips allow the modeler to provide the user with additional
 * information. This Tooltip specification allows different ways
 * to set the help text (directly or via text attribute)
 */
Tooltip:
	TooltipShorthandDefinition | TooltipExtendedDefinition
;

/*
 * This is the shorthand definition of a Tooltip, where
 * the image source will be set in brackets behind the ID
 */
TooltipShorthandDefinition returns Tooltip:
	'Tooltip' name = EID '(' text = STRING ')'
;

/*
 * This is the extended definition of a Tooltip, where
 * the image source will be set as property
 */
TooltipExtendedDefinition returns Tooltip:
	'Tooltip' name = EID '{'
		'text' text = STRING
	'}'
;

/*
 * Images allow the modeler to specify and display images to the user.
 * This Image specification allows different ways to set the
 * image source (directly or via src attribute)
 */
Image:
	ImageShorthandDefinition | ImageExtendedDefinition
;

/*
 * This is the shorthand definition of a Image, where
 * the image source will be set in brackets behind the ID
 */
ImageShorthandDefinition returns Image:
	'Image' name = EID '(' src = STRING ')' ('{' (
		('height' height = INT)? &
		('width' width = INT)?
	) '}')?
;

/*
 * This is the extended definition of a Image, where
 * the image source will be set as property
 */
ImageExtendedDefinition returns Image:
	'Image' name = EID '{' (
		'src' src = STRING &
		('height' height = INT)? &
		('width' width = INT)?
	) '}'
;

/*
 * Labels allow the modeler to present text to the user.
 * Normally they are used to denote input elements. This
 * Label specification allows different ways to set the
 * label text (directly or via text attribute)
 */
Label:
	LabelShorthandDefinition | LabelExtendedDefinition
;

/*
 * This is the shorthand definition of a Label, where
 * the text will be set in brackets behind the ID
 */
LabelShorthandDefinition returns Label:
	'Label' name = EID '(' text = STRING ')' ('{'
		('style' style = StyleAssignment)?
	'}')?
;

/*
 * This is the extended definition of a Label, where
 * the text will be set as property
 */
LabelExtendedDefinition returns Label:
	'Label' name = EID '{' (
		'text' text = STRING &
		('style' style = StyleAssignment)?
	) '}'
;

/*
 * The EntitySelector allows the user to select an element from a list of
 * elements. The textProposition defines which ContentProvider stores the
 * list and which attribute of the elements shall be displayed to the user
 * to allow him to find the desired element.
 */
EntitySelector:
	'EntitySelector' name = EID '{'
		'textProposition' textProposition = ContentProviderPathDefinition
	'}'
;

/////////////////////////////////////
// View layer => Container elements
/////////////////////////////////////

/*
 * ContainerElements are used to composite ViewGUIElements.
 */
ContainerElement:
	GridLayoutPane | FlowLayoutPane | AlternativesPane | TabbedAlternativesPane
;

/*
 * A GridLayoutPane allows the arrangement of ViewGUIElements in a grid structure. The user can specify the
 * number of columns or the number of rows. If one of those is specified the other one will be calculated by
 * MD2. If both are specified and the resulting number of cells is smaller than the number of contained
 * elements, the exceeding elements will be ignored.
 */
GridLayoutPane:
	'GridLayoutPane' name = EID '(' params += GridLayoutPaneParam (',' params += GridLayoutPaneParam)* ')' '{'
		elements += ViewElementType*
	'}'
;

/*
 * The GridLayoutPaneParam specifies all possible parameters for a GridLayoutPane.
 * These are besides the number of columns and rows all TabSpecificParams.
 */
GridLayoutPaneParam:
	{GridLayoutPaneColumnsParam} 'columns' value = INT | {GridLayoutPaneRowsParam} 'rows' value = INT | TabSpecificParam
;

/*
 * A FlowLayoutPane allows the arrangement of ViewGUIElements one after another either horizontally or vertically.
 */
FlowLayoutPane:
	'FlowLayoutPane' name = EID ('(' (params += FlowLayoutPaneParam (',' params += FlowLayoutPaneParam)*)? ')')? '{'
		elements += ViewElementType*
	'}'
;

/*
 * The FlowLayoutPaneParam specifies all possible parameters for a FlowLayoutPane.
 * These are besides the flowDirection all TabSpecificParams.
 */
FlowLayoutPaneParam:
	{FlowLayoutPaneFlowDirectionParam} flowDirection = FlowDirection | TabSpecificParam
;

/*
 * The FlowDirection lists all possible orientations that can be used
 * to define the flow of elements contained in a FlowLayoutPane
 */
enum FlowDirection:
	HORIZONTAL = 'horizontal' | VERTICAL = 'vertical'
;

/*
 * The AlternativesPane allows the definition of several ContainerElements of which one will be
 * shown to the user. The user will be able to choose which ContainerElement shall be displayed. 
 */
AlternativesPane:
	'AlternativesPane' name = EID  ('(' (params += TabSpecificParam (',' params += TabSpecificParam)*)? ')')? '{'
		elements += ContainerElementType*
	'}'
;

/*
 * The TabbedAlternativesPane is a special AlternativesPane that
 * allows the user to switch between tabs by offering him a tab bar.
 */
TabbedAlternativesPane:
	'TabbedPane' name = EID ('(' ')')? '{'
		elements += ContainerElementType*
	'}'
;

/*
 * TabSpecificParam defines the parameters the user can set to a
 * ContainerElement that is contained in a TabbedAlternativesPane.
 */
TabSpecificParam:
	{TabTitleParam} 'tabTitle' tabTitle = STRING | {TabIconParam} 'tabIcon' tabIcon = STRING
;

/////////////////////////////////////
// View layer => Typedef
/////////////////////////////////////

/*
 * The ViewElementType allows to either specify a new ViewGUIElement or to refer to an existing one
 */
ViewElementType:
	{ViewElementRef} value = [ViewGUIElement | QUALIFIED_NAME] (rename ?= '->' name = EID)? |
	{ViewElementDef} value = ViewGUIElement
;

/*
 * The ContainerElementType allows to either specify a new ContainerElement or to refer to an existing one
 */
ContainerElementType:
	{ContainerElementRef} value = [ContainerElement | QUALIFIED_NAME] (rename ?= '->' name = EID)? ('(' (params += TabSpecificParam (',' params += TabSpecificParam)*)? ')')? |
	{ContainerElementDef} value = ContainerElement
;

/////////////////////////////////////
// View layer => Style definitions
/////////////////////////////////////

/*
 * The StyleAssignment allows the user to
 * either define a new Style or to refer
 * to an existing one.
 */
StyleAssignment:
	{StyleDefinition} definition = StyleBody |
	{StyleReference} reference = [Style]
;

/*
 * A Style allows the user to define a
 * new Style in the StyleBody and allow
 * the reference to it by defining a name.
 */
Style:
	'style' name = EID 
	body = StyleBody
;

/*
 * The StyleBody contains the actual style and can be used to set
 * the appearance of the text of some ViewGUIElements. It is
 * possible to set the fontSize, the color and the textStyle.
 */
StyleBody:
	'{' {StyleBody} (
		('fontSize' fontSize = INT)? &
		('color' color = Color)? &
		('textStyle' ((bold?='bold'? & italic?='italic'?) | 'normal'))?
	) '}'
;

/*
 * A Color can be either specified
 * as HEX_COLOR or NamedColor.
 * 
 * Notice:
 * Preprocessing replaces all NamedColors
 * by their hex color equivalents.
 */
Color:
	{HexColorDef} color = HEX_COLOR |
	{NamedColorDef} color = NamedColor
;

/**
 * NamedColor contains the set of the 16 named web colors as specified in HTML 4.01.
 */
enum NamedColor:
	AQUA = 'aqua' | BLACK = 'black' | BLUE = 'blue' | FUCHSIA = 'fuchsia' |
	GRAY = 'gray' | GREEN = 'green' | LIME = 'lime' | MAROON = 'maroon' |
	NAVY = 'navy' | OLIVE = 'olive' | PURPLE ='purple' | RED = 'red' |
	SILVER = 'silver' | TEAL = 'teal' | WHITE = 'white' | YELLOW = 'yellow'
;


/////////////////////////////////////
/////////////////////////////////////
// Controller layer
/////////////////////////////////////
/////////////////////////////////////

/*
 * The root Controller element contains all
 * ControllerElements containing to this view Controller
 */
Controller:
	 controllerElements += ControllerElement+
;

/*
 * The ControllerElement is the super type of all possible ControllerElements.
 */
ControllerElement:
	ContentProvider | Validator | Action | Workflow | OnConditionEvent | Main | RemoteConnection
;

/////////////////////////////////////
// Controller layer => Events
/////////////////////////////////////

/*
 * An Action provides the user the possibility to
 * declare a set of tasks. An Action can be
 * either a CustomAction or a CombinedAction.
 */
Action:
	'action'
		(CustomAction | CombinedAction)
;

/*
 * A CustomAction contains a list of CustomCodeFragments
 * where each CustomCodeFragment contains one task.
 */
CustomAction:
	'CustomAction' name = EID '{'
		codeFragments += CustomCodeFragment*
	'}'
;

/* 
 * CombinedActions allow the composition of Actions.
 */
CombinedAction:
	'CombinedAction' name = EID '{'
		('actions' actions += [Action | QUALIFIED_NAME]+)?
	'}'
;

/*
 * SimpleActions are simple tasks that can be used by the user to declare operations that the app shall perform.
 */
SimpleAction:
	{GotoNextWorkflowStepAction} 'NextStepAction' |
	{GotoPreviousWorkflowStepAction} 'PreviousStepAction' |
	{GotoWorkflowStepAction} ('GotoStepAction' '(' wfStep = [WorkflowStep | QUALIFIED_NAME] (',' silentFails ?= 'silent')? ')') |
	{GotoViewAction} ('GotoViewAction' '(' view = AbstractViewGUIElementRef ')' ) |
	{DataAction} ('DataAction' '(' operation = AllowedOperation contentProvider = [ContentProvider | QUALIFIED_NAME] ')') |
	{NewObjectAtContentProviderAction} ('NewObjectAction' '('contentProvider = [ContentProvider | QUALIFIED_NAME] ')') |
	{AssignObjectAtContentProviderAction} ('AssignObjectAction' '('(bindings += NewObjectEntityBinding (',' bindings += NewObjectEntityBinding)*)? ')') |
	{GPSUpdateAction} 'GPSUpdateAction' '(' bindings += GPSActionEntityBinding (',' bindings += GPSActionEntityBinding)* ')' |
	{SetActiveWorkflowAction} 'SetActiveWorkflowAction' '(' workflow = [Workflow] ')'
;

/*
 * The NewObjectEntityBinding binds a ContentProvider to an object contained in another ContentProvider.
 * 
 * [Move to respective definition] The NewObjectEntityBinding  initializes a new object for the
 * specified Entity or Attribute in the set ContentProvider.
 */
NewObjectEntityBinding:
	'use' contentProvider = [ContentProvider | QUALIFIED_NAME] 'for' path = ContentProviderPathDefinition
;

/*
 * The GPSActionEntityBinding defines the combination of GPSFields
 * and STRINGs and to which Attribute of which Entity
 * stored in which ContentProvider it shall be set.
 */
GPSActionEntityBinding:
	entries += GPSActionEntityBindingEntry ('+' entries += GPSActionEntityBindingEntry)* 'to' path = ContentProviderPathDefinition
;

/*
 * A GPSActionEntityBindingEntry is
 * either one GPSField or a STRING
 */
GPSActionEntityBindingEntry:
	gpsField = GPSField | string = STRING
;

/*
 * The GPSField lists all possible parts of a GPS position that are supported.
 */
enum GPSField:
	LATITUDE = 'latitude' | LONGITUDE = 'longitude' | ALTITUDE = 'altitude' | CITY = 'city' | STREET = 'street' |
	NUMBER = 'number' | POSTAL_CODE = 'postalCode' | COUNTRY = 'country' | PROVINCE = 'province'
;

/////////////////////////////////////
// Controller layer => Custom code
/////////////////////////////////////

/*
 * A CustomCodeFragment is a define the possible commands and tasks that can be declared in a CustomAction.
 * 
 * TODO define all keywords that are supported by our language
 * TODO provide possibility to implement arbitrary code (in theory)
 */
CustomCodeFragment:
	{EventBindingTask} ('bind' ('action' | 'actions') actions+=ActionDef+ 'on' events += EventDef+) |
	{EventUnbindTask} ('unbind' ('action' | 'actions') actions+=ActionDef+ 'from' events += EventDef+) |
	{ValidatorBindingTask} ('bind' ('validator' | 'validators') validators+=ValidatorType+ 'on' (referencedFields += AbstractViewGUIElementRef)+) |
	{ValidatorUnbindTask} ('unbind' ('validator' | 'validators') (validators+=ValidatorType+ | allTypes ?= 'all') 'from' (referencedFields += AbstractViewGUIElementRef)+) |
	{CallTask} ('call' action = ActionDef) |
	{MappingTask} ('map' referencedViewField = AbstractViewGUIElementRef 'to' pathDefinition = ContentProviderPathDefinition) |
	{UnmappingTask} ('unmap' referencedViewField = AbstractViewGUIElementRef 'from' pathDefinition = ContentProviderPathDefinition)
;

/*
 * The AbstractViewGUIElementRef allows to reference any defined ViewGUIElement.
 * First a top level element has to be defined in ref. In tail a recursive navigation
 * to nested elements can be specified. If the last tail points to an
 * AutoGeneratedContentElement path or simpleType can be used to navigate inside the
 * Entity, the ContentProvider is bound on. This will be an reference to the auto
 * generated ViewGUIElement containing the value of the specified Attribute.
 */
AbstractViewGUIElementRef:
	ref = [ecore::EObject | QUALIFIED_NAME] (tail = NestedAbstractViewGUIElementRef | '[' (path = EntityPathDefinition | simpleType = SimpleDataTypeWrapper) ']')?
;

/*
 * The NestedAbstractViewGUIElementRef allows to point to an ViewGUIElement
 * nested in another ViewGUIElement. In tail a recursive navigation
 * to nested elements can be specified. If the last tail points to an
 * AutoGeneratedContentElement path or simpleType can be used to navigate inside the
 * Entity, the ContentProvider is bound on. This will be an reference to the auto
 * generated ViewGUIElement containing the value of the specified Attribute.
 * 
 * A NestedAbstractViewGUIElementRef will result in an AbstractViewGUIElementRef.
 * The difference and reason, why the NestedAbstractViewGUIElementRef is needed,
 * is that AbstractViewGUIElementRef can just point to top level ViewGUIElements
 * while NestedAbstractViewGUIElementRef can point to nested ViewGUIElements.
 * This is important, if a ViewGUIElement referred in a ContainerElement
 * shall be referenced.
 */
NestedAbstractViewGUIElementRef returns AbstractViewGUIElementRef:
	'->' ref = [ecore::EObject | QUALIFIED_NAME] (tail = NestedAbstractViewGUIElementRef | '[' (path = EntityPathDefinition | simpleType = SimpleDataTypeWrapper) ']')?
;

/*
 * The ActionDef allows the user to
 * either define a new Action or or
 * directly a SimpleAction
 */
ActionDef:
	{ActionReference} actionRef = [Action | QUALIFIED_NAME] |
	{SimpleActionRef} action = SimpleAction
;

/*
 * The EventDef allows the user to refer to one of the three possible events.
 */
EventDef:
	{ViewElementEventRef} (referencedField = AbstractViewGUIElementRef '.' event = ElementEventType) |
	{GlobalEventRef} event = GlobalEventType |
	{ConditionalEventRef} eventReference = [OnConditionEvent | QUALIFIED_NAME]
;

/*
 * ElementEventType lists all possible
 * events supported by ViewGUIElements
 */
enum ElementEventType:
	ON_TOUCH = "onTouch" |
	ON_LEFT_SWIPE = "onLeftSwipe" |
	ON_RIGHT_SWIPE = "onRightSwipe" |
	ON_WRONG_VALIDATION = "onWrongValidation"
;

/*
 * GlobalEventType lists all possible app wide events.
 */
enum GlobalEventType:
	CONNECTION_LOST = 'onConnectionLost'
;

/*
 * The ValidatorType allows to either specify
 * a new Validator or to use a StandardValidator
 */
ValidatorType:
	{CustomizedValidatorType} validator = [Validator | QUALIFIED_NAME] |
	{StandardValidatorType} validator = StandardValidator
;


/////////////////////////////////////
// Controller layer => Validators
/////////////////////////////////////

/*
 * Validator allows to declare one of the supported Validators.
 */
Validator:
	'validator' (
		{RegExValidator} 'RegExValidator' name = EID '{' (params += RegExValidatorParam (params += RegExValidatorParam)*) '}' |
		{IsIntValidator} 'IsIntValidator' name = EID '{' (params += ValidatorMessageParam)? '}' |
		{IsNumberValidator} 'IsNumberValidator' name = EID '{' (params += ValidatorMessageParam)? '}' |
		{IsDateValidator} 'IsDateValidator' name = EID '{' ((params += IsDateValidatorParam (params += IsDateValidatorParam)*)?) '}' |
		{NumberRangeValidator} 'NumberRangeValidator' name = EID '{' (params += NumberRangeValidatorParam (params += NumberRangeValidatorParam)*) '}' |
		{StringRangeValidator} 'StringRangeValidator' name = EID '{' (params += StringRangeValidatorParam (params += StringRangeValidatorParam)*) '}' |
		{NotNullValidator} 'NotNullValidator' name = EID '{' (params += ValidatorMessageParam)? '}' |
		RemoteValidator
	)
;

/*
 * The RemoteValidator allows to use a Validator offered by the backend server.
 * 
 * By default only the content and id of the field on which the RemoteValidator has been assigned
 * are transmitted to the backend server. However, additional information can be provided using the
 * provideModel or provideAttributes keyword.
 */
RemoteValidator:
	'RemoteValidator' name = EID '{' (
		(params += ValidatorMessageParam)? &
		('connection' connection = [RemoteConnection])? &
		('model' contentProvider = [ContentProvider] | 'attributes' (provideAttributes += ContentProviderPathDefinition)+)
	) '}'
;

/*
 * StandardValidator contains all Validators that can be directly
 * assigned to input fields without being defined explicitly before.
 * Each StandardValidator supports a set of parameters to allow
 * to define the behavior of the StandardValidator.
 */
StandardValidator:
	{StandardIsIntValidator} 'IsIntValidator' ('(' (params += ValidatorMessageParam)? ')')? |
	{StandardNotNullValidator} 'NotNullValidator' ('(' (params += ValidatorMessageParam)? ')')? |
	{StandardIsNumberValidator} 'IsNumberValidator' ('(' (params += ValidatorMessageParam)? ')')? |
	{StandardIsDateValidator} 'IsDateValidator' ('(' (params += IsDateValidatorParam (',' params += IsDateValidatorParam)*)? ')')? |
	{StandardRegExValidator} 'RegExValidator' '(' params += RegExValidatorParam (',' params += RegExValidatorParam)* ')' |
	{StandardNumberRangeValidator} 'NumberRangeValidator' '(' params += NumberRangeValidatorParam (',' params += NumberRangeValidatorParam)* ')' |
	{StandardStringRangeValidator} 'StringRangeValidator' '(' params += StringRangeValidatorParam (',' params += StringRangeValidatorParam)* ')'
;

/*
 * ValidatorParam is used to define a common super type of all specific ValidatorParams.
 * 
 * The ValidatorParam is not used in the language but will be used by the generators. Therefore
 * it can be seen as a workaround to manipulate the meta model, that will be built by Xtext.
 */
ValidatorParam:
	ValidatorMessageParam | IsDateValidatorParam | RegExValidatorParam | NumberRangeValidatorParam | StringRangeValidatorParam
;

/*
 * ValidatorMessageParam provides the possibility
 * to define a message, that will be shown to the
 * user if the validation fails.
 */
ValidatorMessageParam:
	'message' message = STRING
;

/*
 * The IsDateValidatorParam allows to define a format
 * that the date at hand shall conform to.
 * Additionally it contains the ValidatorMessageParam
 */
IsDateValidatorParam:
	ValidatorMessageParam | {ValidatorFormatParam} 'format' format = STRING
;

/*
 * The RegExValidatorParam allows the definition of a regular
 * expression, that the validator uses to validate the user input.
 * Additionally it contains the ValidatorMessageParam
 */
RegExValidatorParam:
	ValidatorMessageParam | {ValidatorRegExParam} 'regEx' regEx = STRING
;

/*
 * The NumberRangeValidatorParam allows the definition of
 * a numeric range that shall contain the user input.
 * Additionally it contains the ValidatorMessageParam
 */
NumberRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxParam} 'max' max = FLOAT | {ValidatorMinParam} 'min' min = FLOAT
;

/*
 * The StringRangeValidatorParam allows the definition
 * of a string length range. The length of the STRING
 * input by the user will be checked against this range.
 * Additionally it contains the ValidatorMessageParam
 */
StringRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxLengthParam} 'maxLength' maxLength = INT  | {ValidatorMinLengthParam} 'minLength' minLength = INT
;


/////////////////////////////////////
// Controller layer => Main
/////////////////////////////////////

/*
 * The Main object contains all basic information about an app.
 * Each set of models must contain exactly one Main object.
 */
Main:
	'main' '{'
		(
			('appName' appName = STRING) &
			('appVersion' appVersion = STRING) &
			('defaultConnection' defaultConnection = [RemoteConnection])? &
			('startView' startView = AbstractViewGUIElementRef) &
			('modelVersion' modelVersion = STRING) &
			('onInitialized' onInitializedEvent = [Action]) &
			('defaultWorkflow' defaultWorkflow = [Workflow])?
		)
	'}'
;


/////////////////////////////////////
// Controller layer => ContentProvider
/////////////////////////////////////

/*
 * The RemoteConnection allows to specify
 * the connection to a backend server.
 */
RemoteConnection:
	'remoteConnection' name = EID '{' (
		'uri' uri = STRING &
		('password' password = STRING)? &
		('user' user = STRING)? &
		('key' key = STRING)?
	) '}'
;

/*
 * A ContentProvider stores an instance of a ModelElement or a SimpleDataType. It allows to
 * CREATE_OR_UPDATE (save), READ (load) and DELETE (remove) the stored instance. Which of
 * those operations is possible is specified in allowedOperations. By default all operation
 * are allowed. A filter enables to query a subset of all saved instances. The providerType
 * defines whether the instances shall be stored locally or remotely.
 */
ContentProvider:
	'contentProvider' type = DataType name = EID '{' (
		//('cache' ((cache ?= 'true') | 'false'))? &
		'providerType' (default ?= 'default' | local ?= 'local' | connection = [RemoteConnection]) &
		(filter ?= 'filter' filterType = FilterType ('where' whereClause = WhereClauseCondition)?)? &
		('allowedOperations' allowedOperations += AllowedOperation+)? //default = all CRUD operations
	) '}'
;

/*
 * The FilterType lists all possible types of filters.
 */
enum FilterType:
	ALL = 'all' | FIRST = 'first'
;

/*
 * The WhereClauseCondition allows to composite criteria that
 * have to be fulfilled by instances to be loaded.
 */
WhereClauseCondition:
	(ops += 'not')? subConditions += WhereClauseConditionalExpression
	(ops += ('and' | 'or') (ops += 'not')? subConditions += WhereClauseConditionalExpression)*
;

/*
 * The WhereClauseCondition summarizes all possible criteria that
 * have to be fulfilled by instances to be loaded. It resolves to
 * a WhereClauseCondition and is required to allow recursive definition.
 */
WhereClauseConditionalExpression returns WhereClauseCondition:
	('(' WhereClauseCondition ')') |
	{BooleanExpression} value = Boolean |
	{AttributeEqualsExpression} eqLeft = EntityPathDefinition op = Operator eqRight = SimpleExpression
;

/*
 * The Operator defines all Operators
 * that can be used to compare values.
 */
enum Operator:
	EQUALS = 'equals' | GREATER='greater' | SMALLER = 'smaller' |
	GREATER_OR_EQUAL = '>=' | SMALLER_OR_EQUAL = '<='
	// EQUALS = '==' | GREATER = '>' | SMALLER = '<'
	// By now, do not support these equivalents
	// as they lead to an unsupressable warning
;

/*
 * DataType allows to refer to an already defined
 * ModelElement or to use a SimpleDataType.
 */
DataType:
	(
		{ReferencedModelType} entity = [ModelElement | QUALIFIED_NAME] |
		{SimpleType} type = SimpleDataType
	) many ?= BRACKETS?
;

/*
 * A SimpleDataTypeWrapper wraps a SimpleDataType.
 * This is used to store the chosen SimpleDataType
 * of the list of possible SimpleDataTypes.
 */
SimpleDataTypeWrapper:
	type = SimpleDataType
;

/*
 * SimpleDataType lists all possible SimpleDataTypes.
 */
enum SimpleDataType:
	INTEGER = 'integer' | FLOAT = 'float' | STRING = 'string' | BOOLEAN = 'boolean' |
	DATE = 'date' | TIME = 'time' | DATE_TIME = 'timestamp'
;

/*
 * AllowedOperation lists all possible AllowedOperations.
 */
enum AllowedOperation:
	CREATE_OR_UPDATE = 'save' | READ = 'load' | DELETE = 'remove'
;


/////////////////////////////////////
// Controller layer => Workflows
/////////////////////////////////////

/*
 * A Workflow is used to define several steps in which the
 * application can currently be. It is possible to define
 * several Workflows, Workflows can be nested and there
 * is at most one Workflow active.
 */
Workflow:
	'workflow' name = EID '{'
		workflowSteps += WorkflowStep*
	'}'
;

/*
 * Each WorkflowStep defines one view that is related to it
 * and will be displayed if the WorkflowStep becomes the
 * current WorkflowStep of the active Workflow. Additionally
 * conditions can be defined, that restrict switching to the
 * next or previous WorkflowStep. Also events can be
 * specified that trigger the change to the next or previous
 * WorkflowStep. Instead of the former mentioned settings,
 * a Workflow can be referred to that will become active
 * while this WorkflowStep is the current one.
 */
WorkflowStep:
	'step' name = EID ':' (
		('view' view = AbstractViewGUIElementRef &
		('forwardCondition' '{'
			forwardCondition = Condition
		'}')? &
		('forwardMessage' forwardMessage = STRING)? &
		('backwardCondition' '{'
			backwardCondition = Condition
		'}')? &
		('backwardMessage' backwardMessage = STRING)? &
		('forwardOnEvent' forwardEvents += EventDef+)? &
		('backwardOnEvent' backwardEvents += EventDef+)?) |
		'subworkflow' subworkflow = [Workflow]
	)
;

/*
 * The OnConditionEvent provides the user the possibility
 * to define own events. The OnConditionEvent specifies a
 * Condition. If this Condition will be fulfilled, the
 * OnConditionEvent is fired.
 */
OnConditionEvent:
	'event' 'OnConditionEvent' name = EID '{'
		condition = Condition
	'}'
;

/*
 * A Condition allows to compose ConditionalExpressions with the operators 'not', 'and' and 'or'.
 */
Condition:
	(ops+='not')? subConditions += ConditionalExpression (ops += ('and' | 'or') (ops+='not')? subConditions += ConditionalExpression)*
;

/*
 * A ConditionalExpression defines an expression that evaluates to either true or false.
 * It is possible to set a BooleanExpression, an EqualsExpression, that compares to values,
 * or a GuiElementStateExpression that proofs the state of a ViewGUIElement.
 */
ConditionalExpression:
	('(' Condition ')') |
	{BooleanExpression} value = Boolean |
	ComplexConditionalExpression
;

ComplexConditionalExpression returns ConditionalExpression:
		/* 
		 * AbstractViewGUIElementRef is hereby unwantedly a subclass of ConditionalExpression, because Xtext does not remove
		 * the type of the rule call preceding an assigned action (AbstractViewGUIElementRef) from the list of possible return types,
		 * which then become subtypes of this rule's overall return type (ConditionalExpression). 
		 */
	AbstractViewGUIElementRef
	(=>({EqualsExpression.eqLeft=current} 'equals') (not ?= 'not')? eqRight = SimpleExpression | 
	=>({GuiElementStateExpression.reference=current} 'is') (not ?= 'not')? isState = ViewElementState)
;

/*
 * Boolean lists all
 * possible Boolean values.
 */
enum Boolean:
	TRUE='true' | FALSE='false'
;

/*
 * ViewElementState lists all
 * possible ViewElementStates.
 */
enum ViewElementState:
	VALID='valid' | EMPTY='empty' | CHECKED='checked' | FILLED='filled'
;

/*
 * A SimpleExpression contains either a
 * simple data type value of STRING, INT
 * or FLOAT or a Reference to the value
 * of a ViewGUIElement.
 */
SimpleExpression:
	{StringVal} value = STRING |
	{IntVal} value = INT |
	{FloatVal} value = FLOAT |
	AbstractViewGUIElementRef
;


/////////////////////////////////////
/////////////////////////////////////
// Model layer
/////////////////////////////////////
/////////////////////////////////////

/*
 * The root Model element contains all
 * ModelElements containing to this model model
 */
Model:
	 modelElements += ModelElement+
;

/*
 * The ModelElement is
 * the super type of all
 * possible ModelElements.
 */
ModelElement:
	 Entity | Enum
;

/*
 * An Enum allows the user to define
 * a list of STRING values, stored
 * in the enumBody.
 */
Enum:
	'enum' name = EID '{'
		(enumBody = EnumBody)?
	'}'
;

/*
 * An EnumBody allows the user to define
 * a list of STRING values.
 */
EnumBody:
	elements += STRING (',' elements += STRING)*
;

/*
 * An Entity allows the user to define a type,
 * that will be used as data transfer object.
 * The user can provide a list of Attributes.
 */
Entity:
	'entity' name = EID '{'
		attributes += Attribute*
	'}'
;

/*
 * Each Attribute has a name and an AttributeType.
 * Additionally the user can provide further
 * information to an Attribute, namely an
 * extendedName and a description. These further
 * information will be used by the
 * AutoGeneratedContentElement to generate a
 * label and a tooltip.
 */
Attribute:
	name = EID ':' type = AttributeType ('{'
		('name' extendedName = STRING)?
		('description' description = STRING)?
	'}')?
;

/*
 * AttributeType is the super type of all possible AttributeTypes.
 * These can be besides SimpleDataTypes a references to an already
 * defined ModelElement or an implicit Enum declaration.
 */
AttributeType:
	{ReferencedType} entity = [ModelElement | QUALIFIED_NAME]	many ?= BRACKETS? ('(' (params += ReferencedTypeParam (',' params += ReferencedTypeParam)*)? ')')? |
	{IntegerType} 'integer'										many ?= BRACKETS? ('(' (params += IntegerTypeParam (',' params += IntegerTypeParam)*)? ')')? |
	{FloatType} 'float'											many ?= BRACKETS? ('(' (params += FloatTypeParam (',' params += FloatTypeParam)*)? ')')? |
	{StringType} 'string'										many ?= BRACKETS? ('(' (params += StringTypeParam (',' params += StringTypeParam)*)? ')')? |
	{BooleanType} 'boolean'										many ?= BRACKETS? ('(' (params += BooleanTypeParam (',' params += BooleanTypeParam)*)? ')')? |
	{DateType} 'date'											many ?= BRACKETS? ('(' (params += DateTypeParam (',' params += DateTypeParam)*)? ')')? |
	{TimeType} 'time'											many ?= BRACKETS? ('(' (params += TimeTypeParam (',' params += TimeTypeParam)*)? ')')? |
	{DateTimeType} 'timestamp'									many ?= BRACKETS? ('(' (params += DateTimeTypeParam (',' params += DateTimeTypeParam)*)? ')')? |
	
	// EnumType => Transformed to explicit Enum (=> ReferencedType) after preprocessing
	{EnumType} '{' (enumBody = EnumBody)? '}'					many ?= BRACKETS? ('(' (params += EnumTypeParam (',' params += EnumTypeParam)*)? ')')?
;

/*
 * The parser rule BRACKETS defines
 * how square brackets look like.
 * BRACKETS can be annotated to an
 * AttributeType to declare the
 * Attribute to have a one to many
 * relation.
 */
BRACKETS:
	'[' ']'
;

/*
 * PathDefinition is used to define a common super type of all specific PathDefinitions.
 * 
 * The PathDefinition is not used in the language but will be used by the generators. Therefore
 * it can be seen as a workaround to manipulate the meta model, that will be built by Xtext.
 */
PathDefinition:
	ContentProviderPathDefinition | EntityPathDefinition
;

/*
 * The EntityPathDefinition defines
 * a path to an attribute of an entity.
 */
EntityPathDefinition:
	entityRef = [Entity] tail = PathTail
;

/*
 * The ContentProviderPathDefinition
 * defines a path to an attribute of
 * an entity stored in a ContentProvider.
 */
ContentProviderPathDefinition:
	contentProviderRef = [ContentProvider] (tail = PathTail)?
;

/*
 * The PathTail defines a recursive
 * list of nested Attribute references.
 */
PathTail:
	'.' attributeRef = [Attribute] (tail = PathTail)?
;

/////////////////////////////////////
// Attribute parameter definitions
/////////////////////////////////////

// TODO Support default values?

/*
 * AttributeTypeParam is used to define a common super type of all specific AttributeTypeParams.
 * 
 * The AttributeTypeParam is not used in the language but will be used by the generators. Therefore
 * it can be seen as a workaround to manipulate the meta model, that will be built by Xtext.
 */
AttributeTypeParam:
	ReferencedTypeParam | IntegerTypeParam | FloatTypeParam | StringTypeParam | BooleanTypeParam | DateTypeParam | TimeTypeParam | DateTimeTypeParam | EnumTypeParam	
;

/*
 * ReferencedTypeParam is a super type of all
 * possible parameters of referenced Attributes.
 * The value being optional is the only parameter.
 * This parameter will be used to generate a validator.
 */
ReferencedTypeParam:
	{AttrIsOptional} optional ?= 'optional'
;

/*
 * IntegerTypeParam is a super type of all
 * possible parameters of integer Attributes.
 * Besides the value being optional, it is
 * possible to mark it as the identifier of
 * the entity and to provide a minimum and
 * a maximum value. These parameters will
 * be used to generate validators.
 */
IntegerTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrIdentifier} identifier ?= 'identifier' |	
	{AttrIntMax} 'max' max = INT |
	{AttrIntMin} 'min' min = INT
;

/*
 * FloatTypeParam is a super type of all possible
 * parameters of float Attributes. Besides
 * the value being optional, it is possible
 * to provide a minimum and a maximum value.
 * These parameters will be used to generate validators.
 */
FloatTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrFloatMax} 'max' max = FLOAT |
	{AttrFloatMin} 'min' min = FLOAT
;

/*
 * StringTypeParam is a super type of all possible
 * parameters of string Attributes. Besides the
 * value being optional, it is possible to mark
 * it as the identifier of the entity and to
 * provide a minimum and a maximum string length.
 * These parameters will be used to generate validators.
 */
StringTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrIdentifier} identifier ?= 'identifier' |
	{AttrStringMax} 'maxLength' max = INT |
	{AttrStringMin} 'minLength' min = INT
;

/*
 * BooleanTypeParam is a super type of all
 * possible parameters of boolean Attributes.
 * The value being optional is the only
 * parameter. This parameter will be used
 * to generate a validator.
 */
BooleanTypeParam:
	{AttrIsOptional} optional ?= 'optional'
;

/*
 * DateTypeParam is a super type of all
 * possible parameters of date Attributes.
 * Besides the value being optional, it
 * is possible to provide a minimum and a
 * maximum value. These parameters will
 * be used to generate validators.
 */
DateTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrDateMax} 'max' max = DATE |
	{AttrDateMin} 'min' min = DATE
;

/*
 * TimeTypeParam is a super type of all
 * possible parameters of time Attributes.
 * Besides the value being optional, it
 * is possible to provide a minimum and a
 * maximum value. These parameters will
 * be used to generate validators.
 */
TimeTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrTimeMax} 'max' max = TIME |
	{AttrTimeMin} 'min' min = TIME
;

/*
 * DateTimeTypeParam is a super type of
 * all possible parameters of datetime
 * Attributes. Besides the value being
 * optional, it is possible to provide
 * a minimum and a maximum value. These
 * parameters will be used to generate
 * validators.
 */
DateTimeTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrDateTimeMax} 'max' max = DATE_TIME |
	{AttrDateTimeMin} 'min' min = DATE_TIME
;

/*
 * ReferencedTypeParam is a super type of
 * all possible parameters of referenced
 * Attributes. The value being optional
 * is the only parameter. This parameter
 * will be used to generate a validator.
 */
EnumTypeParam:
	{AttrIsOptional} optional ?= 'optional'
;


/////////////////////////////////////
/////////////////////////////////////
// Terminal and data type rules
/////////////////////////////////////
/////////////////////////////////////

/**
 * Definition of a date. A string that conforms of the following format is expected:
 * YYYY-MM-DD
 */
DATE returns ecore::EDate:
	STRING
;

/**
 * Definition of the time. A string that conforms of the following format is expected:
 * hh:mm:ss[.nnnnnnn][(+|-)hh[:mm]] or hh:mm:ss[.nnnnnnn][Z]
 */
TIME returns ecore::EDate:
	STRING
;

/**
 * Definition of date and time. A string that conforms ISO 8601 is expected.
 * YYYY-MM-DDThh:mm:ss[.nnnnnnn][(+|-)hh[:mm]] or
 * YYYY-MM-DDThh:mm:ss[.nnnnnnn][Z]
 */
DATE_TIME returns ecore::EDate:
	STRING
;

/**
 * Float #.#
 */
FLOAT returns ecore::EDouble:
	INT '.' INT
;

/*
 * Extended, keyword insensitive ID. Using the EID allows to use a known keyword as an ID.
 */
EID:
	'type' | 'default' | 'label' | 'tooltip' | 'options' | 'contentProvider' | 'exclude' |
	'tabTitle' | 'tabIcon' | 'textProposition' |
	'displayAll' | 'fontSize' | 'color' | 'textStyle' | 'bold' | 'italic' | 'normal' |
	'aqua' | 'black' | 'blue' | 'gray' | 'green' | 'lime' | 'maroon' | 'navy' | 'olive' | 'purple' |
	'red' | 'silver' | 'white' | 'yellow' | 'action' | 'actions' |
	'silent' | 'event' | 'valid' | 'empty' | 'filled' | 'enum' | 'entity' | 'name' |
	'description' | 'optional' | 'latitude' | 'longitude' | 'altitude' | 'city' | 'street' | 'number' |
	'postalCode' | 'country' | 'province' |	ID
	
	//	'only' | 'style' | 'text' | 'checked' | 'height' | 'width' |
	//	'src' | 'columns' | 'rows' | 'horizontal' | 'vertical' |
	//	'onRightSwipe' | 'onWrongValidation' | 'onConnectionLost' | 'validator' |
	//	'connection' | 'model' | 'attributes' | 'message' | 'format' | 'regEx' | 'max' | 'min' |
	//	'maxLength' | 'minLength' | 'main' | 'appName' | 'appVersion' | 'defaultConnection' | 'startView' | 'modelVersion' |
	//	'uri' | 'password' | 'user' | 'key' |
	//	'cache' | 'providerType' | 'local' | 'filter' | 'where' | 'allowedOperations' | 'first' | 
	//	'save' | 'load' | 'remove' | 'workflow' | 'step' |
	//	'forwardMessage' | 'backwardMessage' | 'validator' | 'validators' | 
	//	'unbind' | 'map' | 'unmap' | 'all' | 'call' | 'onTouch' | 'onLeftSwipe' | 'use' | 'for' | 'to' | 'bind' | 'on' | 'from'
	//	'forwardCondition' | 'forwardOnEvent' | 'backwardCondition' | 'backwardOnEvent' |'view' | 'onInitialized' | 'defaultWorkflow' | 
	//	'integer' | 'float' | 'string' | 'boolean' | 'date' | 'time' | 'timestamp' | 'remoteConnection' |  'contentProvider' |
;

/**
 * Qualified names of the form
 * <tt>ID (.ID)*</tt>
 */
QUALIFIED_NAME:
	EID ('.' EID)*
;

/**
 * Hexadecimal color definitions of the form #ffffff or #ffffffff.
 * In the 8-digit definition the leading two digits specify the (optional) alpha channel.
 */
terminal HEX_COLOR:
	'#'
	(('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f'))?
	('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f')
	('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f')
	('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f')
;
