/*
 * generated by Xtext
 */
package de.wwu.md2.framework.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.wwu.md2.framework.mD2.AbstractViewGUIElementRef;
import de.wwu.md2.framework.mD2.ActionReference;
import de.wwu.md2.framework.mD2.AlternativesPane;
import de.wwu.md2.framework.mD2.And;
import de.wwu.md2.framework.mD2.App;
import de.wwu.md2.framework.mD2.AttrBooleanDefault;
import de.wwu.md2.framework.mD2.AttrDateDefault;
import de.wwu.md2.framework.mD2.AttrDateMax;
import de.wwu.md2.framework.mD2.AttrDateMin;
import de.wwu.md2.framework.mD2.AttrDateTimeDefault;
import de.wwu.md2.framework.mD2.AttrDateTimeMax;
import de.wwu.md2.framework.mD2.AttrDateTimeMin;
import de.wwu.md2.framework.mD2.AttrEnumDefault;
import de.wwu.md2.framework.mD2.AttrFloatDefault;
import de.wwu.md2.framework.mD2.AttrFloatMax;
import de.wwu.md2.framework.mD2.AttrFloatMin;
import de.wwu.md2.framework.mD2.AttrIdentifier;
import de.wwu.md2.framework.mD2.AttrIntDefault;
import de.wwu.md2.framework.mD2.AttrIntMax;
import de.wwu.md2.framework.mD2.AttrIntMin;
import de.wwu.md2.framework.mD2.AttrIsOptional;
import de.wwu.md2.framework.mD2.AttrStringDefault;
import de.wwu.md2.framework.mD2.AttrStringMax;
import de.wwu.md2.framework.mD2.AttrStringMin;
import de.wwu.md2.framework.mD2.AttrTimeDefault;
import de.wwu.md2.framework.mD2.AttrTimeMax;
import de.wwu.md2.framework.mD2.AttrTimeMin;
import de.wwu.md2.framework.mD2.Attribute;
import de.wwu.md2.framework.mD2.AttributeSetTask;
import de.wwu.md2.framework.mD2.AutoGeneratedContentElement;
import de.wwu.md2.framework.mD2.BooleanExpression;
import de.wwu.md2.framework.mD2.BooleanInput;
import de.wwu.md2.framework.mD2.BooleanRestParam;
import de.wwu.md2.framework.mD2.BooleanType;
import de.wwu.md2.framework.mD2.BooleanVal;
import de.wwu.md2.framework.mD2.Button;
import de.wwu.md2.framework.mD2.CallTask;
import de.wwu.md2.framework.mD2.CombinedAction;
import de.wwu.md2.framework.mD2.CompareExpression;
import de.wwu.md2.framework.mD2.ConcatenatedString;
import de.wwu.md2.framework.mD2.ConditionalCodeFragment;
import de.wwu.md2.framework.mD2.ConditionalEventRef;
import de.wwu.md2.framework.mD2.ContainerElementReference;
import de.wwu.md2.framework.mD2.ContentProvider;
import de.wwu.md2.framework.mD2.ContentProviderAddAction;
import de.wwu.md2.framework.mD2.ContentProviderEventRef;
import de.wwu.md2.framework.mD2.ContentProviderGetAction;
import de.wwu.md2.framework.mD2.ContentProviderOperationAction;
import de.wwu.md2.framework.mD2.ContentProviderPath;
import de.wwu.md2.framework.mD2.ContentProviderPathEventRef;
import de.wwu.md2.framework.mD2.ContentProviderReference;
import de.wwu.md2.framework.mD2.ContentProviderRemoveAction;
import de.wwu.md2.framework.mD2.ContentProviderResetAction;
import de.wwu.md2.framework.mD2.ContentProviderRestParam;
import de.wwu.md2.framework.mD2.ContentProviderSetTask;
import de.wwu.md2.framework.mD2.Controller;
import de.wwu.md2.framework.mD2.CustomAction;
import de.wwu.md2.framework.mD2.CustomizedValidatorType;
import de.wwu.md2.framework.mD2.DateInput;
import de.wwu.md2.framework.mD2.DateRangeValidator;
import de.wwu.md2.framework.mD2.DateTimeInput;
import de.wwu.md2.framework.mD2.DateTimeRangeValidator;
import de.wwu.md2.framework.mD2.DateTimeType;
import de.wwu.md2.framework.mD2.DateTimeVal;
import de.wwu.md2.framework.mD2.DateType;
import de.wwu.md2.framework.mD2.DateVal;
import de.wwu.md2.framework.mD2.DisableAction;
import de.wwu.md2.framework.mD2.DisplayMessageAction;
import de.wwu.md2.framework.mD2.Div;
import de.wwu.md2.framework.mD2.ElseCodeBlock;
import de.wwu.md2.framework.mD2.EnableAction;
import de.wwu.md2.framework.mD2.Entity;
import de.wwu.md2.framework.mD2.EntityPath;
import de.wwu.md2.framework.mD2.EntitySelector;
import de.wwu.md2.framework.mD2.EnumBody;
import de.wwu.md2.framework.mD2.EnumType;
import de.wwu.md2.framework.mD2.EventBindingTask;
import de.wwu.md2.framework.mD2.EventUnbindTask;
import de.wwu.md2.framework.mD2.FileType;
import de.wwu.md2.framework.mD2.FileUpload;
import de.wwu.md2.framework.mD2.FireEventAction;
import de.wwu.md2.framework.mD2.FireEventEntry;
import de.wwu.md2.framework.mD2.FloatRestParam;
import de.wwu.md2.framework.mD2.FloatType;
import de.wwu.md2.framework.mD2.FloatVal;
import de.wwu.md2.framework.mD2.FlowLayoutPane;
import de.wwu.md2.framework.mD2.FlowLayoutPaneFlowDirectionParam;
import de.wwu.md2.framework.mD2.GlobalEventRef;
import de.wwu.md2.framework.mD2.GotoViewAction;
import de.wwu.md2.framework.mD2.GridLayoutPane;
import de.wwu.md2.framework.mD2.GridLayoutPaneColumnsParam;
import de.wwu.md2.framework.mD2.GridLayoutPaneRowsParam;
import de.wwu.md2.framework.mD2.GuiElementStateExpression;
import de.wwu.md2.framework.mD2.HexColorDef;
import de.wwu.md2.framework.mD2.IfCodeBlock;
import de.wwu.md2.framework.mD2.Image;
import de.wwu.md2.framework.mD2.IntVal;
import de.wwu.md2.framework.mD2.IntegerInput;
import de.wwu.md2.framework.mD2.IntegerRestParam;
import de.wwu.md2.framework.mD2.IntegerType;
import de.wwu.md2.framework.mD2.InvokeBooleanValue;
import de.wwu.md2.framework.mD2.InvokeDateTimeValue;
import de.wwu.md2.framework.mD2.InvokeDateValue;
import de.wwu.md2.framework.mD2.InvokeDefaultValue;
import de.wwu.md2.framework.mD2.InvokeDefinition;
import de.wwu.md2.framework.mD2.InvokeFloatValue;
import de.wwu.md2.framework.mD2.InvokeIntValue;
import de.wwu.md2.framework.mD2.InvokeSetContentProvider;
import de.wwu.md2.framework.mD2.InvokeStringValue;
import de.wwu.md2.framework.mD2.InvokeTimeValue;
import de.wwu.md2.framework.mD2.InvokeWSParam;
import de.wwu.md2.framework.mD2.Label;
import de.wwu.md2.framework.mD2.LocationAction;
import de.wwu.md2.framework.mD2.LocationProviderPath;
import de.wwu.md2.framework.mD2.LocationProviderReference;
import de.wwu.md2.framework.mD2.MD2Model;
import de.wwu.md2.framework.mD2.MD2Package;
import de.wwu.md2.framework.mD2.Main;
import de.wwu.md2.framework.mD2.MappingTask;
import de.wwu.md2.framework.mD2.Minus;
import de.wwu.md2.framework.mD2.Model;
import de.wwu.md2.framework.mD2.Mult;
import de.wwu.md2.framework.mD2.NamedColorDef;
import de.wwu.md2.framework.mD2.Not;
import de.wwu.md2.framework.mD2.NotNullValidator;
import de.wwu.md2.framework.mD2.NumberInput;
import de.wwu.md2.framework.mD2.NumberRangeValidator;
import de.wwu.md2.framework.mD2.OnConditionEvent;
import de.wwu.md2.framework.mD2.OptionInput;
import de.wwu.md2.framework.mD2.Or;
import de.wwu.md2.framework.mD2.PackageDefinition;
import de.wwu.md2.framework.mD2.PathTail;
import de.wwu.md2.framework.mD2.Plus;
import de.wwu.md2.framework.mD2.ProcessChain;
import de.wwu.md2.framework.mD2.ProcessChainGoToDefinition;
import de.wwu.md2.framework.mD2.ProcessChainGoToNext;
import de.wwu.md2.framework.mD2.ProcessChainGoToPrevious;
import de.wwu.md2.framework.mD2.ProcessChainGoToSpecExtended;
import de.wwu.md2.framework.mD2.ProcessChainGoToSpecShorthand;
import de.wwu.md2.framework.mD2.ProcessChainGoToStep;
import de.wwu.md2.framework.mD2.ProcessChainGotoAction;
import de.wwu.md2.framework.mD2.ProcessChainProceedAction;
import de.wwu.md2.framework.mD2.ProcessChainReturn;
import de.wwu.md2.framework.mD2.ProcessChainReverseAction;
import de.wwu.md2.framework.mD2.ProcessChainStep;
import de.wwu.md2.framework.mD2.RESTParam;
import de.wwu.md2.framework.mD2.ReferencedModelType;
import de.wwu.md2.framework.mD2.ReferencedType;
import de.wwu.md2.framework.mD2.RegExValidator;
import de.wwu.md2.framework.mD2.RemoteConnection;
import de.wwu.md2.framework.mD2.RemoteValidator;
import de.wwu.md2.framework.mD2.SetProcessChainAction;
import de.wwu.md2.framework.mD2.SimpleActionRef;
import de.wwu.md2.framework.mD2.SimpleDataTypeWrapper;
import de.wwu.md2.framework.mD2.SimpleType;
import de.wwu.md2.framework.mD2.Spacer;
import de.wwu.md2.framework.mD2.StandardDateRangeValidator;
import de.wwu.md2.framework.mD2.StandardDateTimeRangeValidator;
import de.wwu.md2.framework.mD2.StandardNotNullValidator;
import de.wwu.md2.framework.mD2.StandardNumberRangeValidator;
import de.wwu.md2.framework.mD2.StandardRegExValidator;
import de.wwu.md2.framework.mD2.StandardStringRangeValidator;
import de.wwu.md2.framework.mD2.StandardTimeRangeValidator;
import de.wwu.md2.framework.mD2.StandardValidatorType;
import de.wwu.md2.framework.mD2.StringRangeValidator;
import de.wwu.md2.framework.mD2.StringRestParam;
import de.wwu.md2.framework.mD2.StringType;
import de.wwu.md2.framework.mD2.StringVal;
import de.wwu.md2.framework.mD2.Style;
import de.wwu.md2.framework.mD2.StyleBody;
import de.wwu.md2.framework.mD2.StyleDefinition;
import de.wwu.md2.framework.mD2.StyleReference;
import de.wwu.md2.framework.mD2.TabIconParam;
import de.wwu.md2.framework.mD2.TabTitleParam;
import de.wwu.md2.framework.mD2.TabbedAlternativesPane;
import de.wwu.md2.framework.mD2.TextInput;
import de.wwu.md2.framework.mD2.TimeInput;
import de.wwu.md2.framework.mD2.TimeRangeValidator;
import de.wwu.md2.framework.mD2.TimeType;
import de.wwu.md2.framework.mD2.TimeVal;
import de.wwu.md2.framework.mD2.Tooltip;
import de.wwu.md2.framework.mD2.UnmappingTask;
import de.wwu.md2.framework.mD2.UploadedImageOutput;
import de.wwu.md2.framework.mD2.ValidatorBindingTask;
import de.wwu.md2.framework.mD2.ValidatorMaxDateParam;
import de.wwu.md2.framework.mD2.ValidatorMaxDateTimeParam;
import de.wwu.md2.framework.mD2.ValidatorMaxLengthParam;
import de.wwu.md2.framework.mD2.ValidatorMaxParam;
import de.wwu.md2.framework.mD2.ValidatorMaxTimeParam;
import de.wwu.md2.framework.mD2.ValidatorMessageParam;
import de.wwu.md2.framework.mD2.ValidatorMinDateParam;
import de.wwu.md2.framework.mD2.ValidatorMinDateTimeParam;
import de.wwu.md2.framework.mD2.ValidatorMinLengthParam;
import de.wwu.md2.framework.mD2.ValidatorMinParam;
import de.wwu.md2.framework.mD2.ValidatorMinTimeParam;
import de.wwu.md2.framework.mD2.ValidatorRegExParam;
import de.wwu.md2.framework.mD2.ValidatorUnbindTask;
import de.wwu.md2.framework.mD2.View;
import de.wwu.md2.framework.mD2.ViewElementEventRef;
import de.wwu.md2.framework.mD2.ViewElementSetTask;
import de.wwu.md2.framework.mD2.ViewGUIElementReference;
import de.wwu.md2.framework.mD2.WebServiceCall;
import de.wwu.md2.framework.mD2.WebServiceCallAction;
import de.wwu.md2.framework.mD2.WhereClauseAnd;
import de.wwu.md2.framework.mD2.WhereClauseCompareExpression;
import de.wwu.md2.framework.mD2.WhereClauseNot;
import de.wwu.md2.framework.mD2.WhereClauseOr;
import de.wwu.md2.framework.mD2.WidthParam;
import de.wwu.md2.framework.mD2.Workflow;
import de.wwu.md2.framework.mD2.WorkflowElement;
import de.wwu.md2.framework.mD2.WorkflowElementEntry;
import de.wwu.md2.framework.mD2.WorkflowElementReference;
import de.wwu.md2.framework.mD2.WorkflowEvent;
import de.wwu.md2.framework.services.MD2GrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractMD2SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MD2GrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == MD2Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case MD2Package.ABSTRACT_VIEW_GUI_ELEMENT_REF:
				if(context == grammarAccess.getAbstractViewGUIElementRefRule() ||
				   context == grammarAccess.getAdditionSubtractionRule() ||
				   context == grammarAccess.getAdditionSubtractionAccess().getMinusLeftOperandAction_1_0_1_0() ||
				   context == grammarAccess.getAdditionSubtractionAccess().getPlusLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getComplexConditionalExpressionAccess().getCompareExpressionEqLeftAction_1_1() ||
				   context == grammarAccess.getComplexConditionalExpressionAccess().getGuiElementStateExpressionReferenceAction_0_1() ||
				   context == grammarAccess.getConcatenatedStringRule() ||
				   context == grammarAccess.getConcatenatedStringAccess().getConcatenatedStringLeftStringAction_1_0() ||
				   context == grammarAccess.getCustomCodeFragmentAccess().getViewElementSetTaskReferencedViewFieldAction_5_1_2_1() ||
				   context == grammarAccess.getMathExpressionRule() ||
				   context == grammarAccess.getMathLiteralRule() ||
				   context == grammarAccess.getMathSubExpressionRule() ||
				   context == grammarAccess.getMultiplicationDivisionRule() ||
				   context == grammarAccess.getMultiplicationDivisionAccess().getDivLeftOperandAction_1_0_1_0() ||
				   context == grammarAccess.getMultiplicationDivisionAccess().getMultLeftOperandAction_1_0_0_0() ||
				   context == grammarAccess.getSimpleExpressionRule() ||
				   context == grammarAccess.getStringPartialRule()) {
					sequence_AbstractViewGUIElementRef(context, (AbstractViewGUIElementRef) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNestedAbstractViewGUIElementRefRule()) {
					sequence_NestedAbstractViewGUIElementRef(context, (AbstractViewGUIElementRef) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.ACTION_REFERENCE:
				sequence_ActionDef(context, (ActionReference) semanticObject); 
				return; 
			case MD2Package.ALTERNATIVES_PANE:
				sequence_AlternativesPane(context, (AlternativesPane) semanticObject); 
				return; 
			case MD2Package.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MD2Package.APP:
				sequence_App(context, (App) semanticObject); 
				return; 
			case MD2Package.ATTR_BOOLEAN_DEFAULT:
				sequence_BooleanTypeParam(context, (AttrBooleanDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_DATE_DEFAULT:
				sequence_DateTypeParam(context, (AttrDateDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_DATE_MAX:
				sequence_DateTypeParam(context, (AttrDateMax) semanticObject); 
				return; 
			case MD2Package.ATTR_DATE_MIN:
				sequence_DateTypeParam(context, (AttrDateMin) semanticObject); 
				return; 
			case MD2Package.ATTR_DATE_TIME_DEFAULT:
				sequence_DateTimeTypeParam(context, (AttrDateTimeDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_DATE_TIME_MAX:
				sequence_DateTimeTypeParam(context, (AttrDateTimeMax) semanticObject); 
				return; 
			case MD2Package.ATTR_DATE_TIME_MIN:
				sequence_DateTimeTypeParam(context, (AttrDateTimeMin) semanticObject); 
				return; 
			case MD2Package.ATTR_ENUM_DEFAULT:
				if(context == grammarAccess.getAttributeTypeParamRule()) {
					sequence_AttributeTypeParam_EnumTypeParam_ReferencedTypeParam(context, (AttrEnumDefault) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEnumTypeParamRule()) {
					sequence_EnumTypeParam(context, (AttrEnumDefault) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getReferencedTypeParamRule()) {
					sequence_ReferencedTypeParam(context, (AttrEnumDefault) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.ATTR_FLOAT_DEFAULT:
				sequence_FloatTypeParam(context, (AttrFloatDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_FLOAT_MAX:
				sequence_FloatTypeParam(context, (AttrFloatMax) semanticObject); 
				return; 
			case MD2Package.ATTR_FLOAT_MIN:
				sequence_FloatTypeParam(context, (AttrFloatMin) semanticObject); 
				return; 
			case MD2Package.ATTR_IDENTIFIER:
				if(context == grammarAccess.getAttributeTypeParamRule()) {
					sequence_AttributeTypeParam_IntegerTypeParam_StringTypeParam(context, (AttrIdentifier) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getIntegerTypeParamRule()) {
					sequence_IntegerTypeParam(context, (AttrIdentifier) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getStringTypeParamRule()) {
					sequence_StringTypeParam(context, (AttrIdentifier) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.ATTR_INT_DEFAULT:
				sequence_IntegerTypeParam(context, (AttrIntDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_INT_MAX:
				sequence_IntegerTypeParam(context, (AttrIntMax) semanticObject); 
				return; 
			case MD2Package.ATTR_INT_MIN:
				sequence_IntegerTypeParam(context, (AttrIntMin) semanticObject); 
				return; 
			case MD2Package.ATTR_IS_OPTIONAL:
				if(context == grammarAccess.getAttributeTypeParamRule()) {
					sequence_AttributeTypeParam_BooleanTypeParam_DateTimeTypeParam_DateTypeParam_EnumTypeParam_FileTypeParam_FloatTypeParam_IntegerTypeParam_ReferencedTypeParam_StringTypeParam_TimeTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getBooleanTypeParamRule()) {
					sequence_BooleanTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDateTimeTypeParamRule()) {
					sequence_DateTimeTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDateTypeParamRule()) {
					sequence_DateTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEnumTypeParamRule()) {
					sequence_EnumTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFileTypeParamRule()) {
					sequence_FileTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFloatTypeParamRule()) {
					sequence_FloatTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getIntegerTypeParamRule()) {
					sequence_IntegerTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getReferencedTypeParamRule()) {
					sequence_ReferencedTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getStringTypeParamRule()) {
					sequence_StringTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getTimeTypeParamRule()) {
					sequence_TimeTypeParam(context, (AttrIsOptional) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.ATTR_STRING_DEFAULT:
				sequence_StringTypeParam(context, (AttrStringDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_STRING_MAX:
				sequence_StringTypeParam(context, (AttrStringMax) semanticObject); 
				return; 
			case MD2Package.ATTR_STRING_MIN:
				sequence_StringTypeParam(context, (AttrStringMin) semanticObject); 
				return; 
			case MD2Package.ATTR_TIME_DEFAULT:
				sequence_TimeTypeParam(context, (AttrTimeDefault) semanticObject); 
				return; 
			case MD2Package.ATTR_TIME_MAX:
				sequence_TimeTypeParam(context, (AttrTimeMax) semanticObject); 
				return; 
			case MD2Package.ATTR_TIME_MIN:
				sequence_TimeTypeParam(context, (AttrTimeMin) semanticObject); 
				return; 
			case MD2Package.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case MD2Package.ATTRIBUTE_SET_TASK:
				sequence_CustomCodeFragment(context, (AttributeSetTask) semanticObject); 
				return; 
			case MD2Package.AUTO_GENERATED_CONTENT_ELEMENT:
				sequence_AutoGeneratedContentElement(context, (AutoGeneratedContentElement) semanticObject); 
				return; 
			case MD2Package.BOOLEAN_EXPRESSION:
				sequence_ConditionalExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case MD2Package.BOOLEAN_INPUT:
				sequence_BooleanInput(context, (BooleanInput) semanticObject); 
				return; 
			case MD2Package.BOOLEAN_REST_PARAM:
				sequence_RESTValue(context, (BooleanRestParam) semanticObject); 
				return; 
			case MD2Package.BOOLEAN_TYPE:
				sequence_AttributeType(context, (BooleanType) semanticObject); 
				return; 
			case MD2Package.BOOLEAN_VAL:
				sequence_StringPartial(context, (BooleanVal) semanticObject); 
				return; 
			case MD2Package.BUTTON:
				if(context == grammarAccess.getButtonExtendedDefinitionRule()) {
					sequence_ButtonExtendedDefinition(context, (Button) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getButtonShorthandDefinitionRule()) {
					sequence_ButtonShorthandDefinition(context, (Button) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getButtonRule() ||
				   context == grammarAccess.getContentElementRule() ||
				   context == grammarAccess.getViewElementRule() ||
				   context == grammarAccess.getViewElementTypeRule() ||
				   context == grammarAccess.getViewGUIElementRule()) {
					sequence_Button_ButtonExtendedDefinition_ButtonShorthandDefinition(context, (Button) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.CALL_TASK:
				sequence_CustomCodeFragment(context, (CallTask) semanticObject); 
				return; 
			case MD2Package.COMBINED_ACTION:
				sequence_CombinedAction(context, (CombinedAction) semanticObject); 
				return; 
			case MD2Package.COMPARE_EXPRESSION:
				sequence_ComplexConditionalExpression(context, (CompareExpression) semanticObject); 
				return; 
			case MD2Package.CONCATENATED_STRING:
				sequence_ConcatenatedString(context, (ConcatenatedString) semanticObject); 
				return; 
			case MD2Package.CONDITIONAL_CODE_FRAGMENT:
				sequence_CustomCodeFragment(context, (ConditionalCodeFragment) semanticObject); 
				return; 
			case MD2Package.CONDITIONAL_EVENT_REF:
				sequence_EventDef(context, (ConditionalEventRef) semanticObject); 
				return; 
			case MD2Package.CONTAINER_ELEMENT_REFERENCE:
				sequence_ContainerElementReference(context, (ContainerElementReference) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER:
				sequence_ContentProvider(context, (ContentProvider) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_ADD_ACTION:
				sequence_SimpleAction(context, (ContentProviderAddAction) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_EVENT_REF:
				sequence_EventDef(context, (ContentProviderEventRef) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_GET_ACTION:
				sequence_SimpleAction(context, (ContentProviderGetAction) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_OPERATION_ACTION:
				sequence_SimpleAction(context, (ContentProviderOperationAction) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_PATH:
				sequence_ContentProviderPath(context, (ContentProviderPath) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_PATH_EVENT_REF:
				sequence_EventDef(context, (ContentProviderPathEventRef) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_REFERENCE:
				sequence_ContentProviderReference(context, (ContentProviderReference) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_REMOVE_ACTION:
				sequence_SimpleAction(context, (ContentProviderRemoveAction) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_RESET_ACTION:
				sequence_SimpleAction(context, (ContentProviderResetAction) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_REST_PARAM:
				sequence_RESTValue(context, (ContentProviderRestParam) semanticObject); 
				return; 
			case MD2Package.CONTENT_PROVIDER_SET_TASK:
				sequence_CustomCodeFragment(context, (ContentProviderSetTask) semanticObject); 
				return; 
			case MD2Package.CONTROLLER:
				sequence_Controller(context, (Controller) semanticObject); 
				return; 
			case MD2Package.CUSTOM_ACTION:
				sequence_CustomAction(context, (CustomAction) semanticObject); 
				return; 
			case MD2Package.CUSTOMIZED_VALIDATOR_TYPE:
				sequence_ValidatorType(context, (CustomizedValidatorType) semanticObject); 
				return; 
			case MD2Package.DATE_INPUT:
				sequence_DateInput(context, (DateInput) semanticObject); 
				return; 
			case MD2Package.DATE_RANGE_VALIDATOR:
				sequence_Validator(context, (DateRangeValidator) semanticObject); 
				return; 
			case MD2Package.DATE_TIME_INPUT:
				sequence_DateTimeInput(context, (DateTimeInput) semanticObject); 
				return; 
			case MD2Package.DATE_TIME_RANGE_VALIDATOR:
				sequence_Validator(context, (DateTimeRangeValidator) semanticObject); 
				return; 
			case MD2Package.DATE_TIME_TYPE:
				sequence_AttributeType(context, (DateTimeType) semanticObject); 
				return; 
			case MD2Package.DATE_TIME_VAL:
				sequence_StringPartial(context, (DateTimeVal) semanticObject); 
				return; 
			case MD2Package.DATE_TYPE:
				sequence_AttributeType(context, (DateType) semanticObject); 
				return; 
			case MD2Package.DATE_VAL:
				sequence_StringPartial(context, (DateVal) semanticObject); 
				return; 
			case MD2Package.DISABLE_ACTION:
				sequence_SimpleAction(context, (DisableAction) semanticObject); 
				return; 
			case MD2Package.DISPLAY_MESSAGE_ACTION:
				sequence_SimpleAction(context, (DisplayMessageAction) semanticObject); 
				return; 
			case MD2Package.DIV:
				sequence_MultiplicationDivision(context, (Div) semanticObject); 
				return; 
			case MD2Package.ELSE_CODE_BLOCK:
				sequence_ElseCodeBlock(context, (ElseCodeBlock) semanticObject); 
				return; 
			case MD2Package.ENABLE_ACTION:
				sequence_SimpleAction(context, (EnableAction) semanticObject); 
				return; 
			case MD2Package.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MD2Package.ENTITY_PATH:
				sequence_EntityPath(context, (EntityPath) semanticObject); 
				return; 
			case MD2Package.ENTITY_SELECTOR:
				sequence_EntitySelector(context, (EntitySelector) semanticObject); 
				return; 
			case MD2Package.ENUM:
				sequence_Enum(context, (de.wwu.md2.framework.mD2.Enum) semanticObject); 
				return; 
			case MD2Package.ENUM_BODY:
				sequence_EnumBody(context, (EnumBody) semanticObject); 
				return; 
			case MD2Package.ENUM_TYPE:
				sequence_AttributeType(context, (EnumType) semanticObject); 
				return; 
			case MD2Package.EVENT_BINDING_TASK:
				sequence_CustomCodeFragment(context, (EventBindingTask) semanticObject); 
				return; 
			case MD2Package.EVENT_UNBIND_TASK:
				sequence_CustomCodeFragment(context, (EventUnbindTask) semanticObject); 
				return; 
			case MD2Package.FILE_TYPE:
				sequence_AttributeType(context, (FileType) semanticObject); 
				return; 
			case MD2Package.FILE_UPLOAD:
				sequence_FileUpload(context, (FileUpload) semanticObject); 
				return; 
			case MD2Package.FIRE_EVENT_ACTION:
				sequence_SimpleAction(context, (FireEventAction) semanticObject); 
				return; 
			case MD2Package.FIRE_EVENT_ENTRY:
				sequence_FireEventEntry(context, (FireEventEntry) semanticObject); 
				return; 
			case MD2Package.FLOAT_REST_PARAM:
				sequence_RESTValue(context, (FloatRestParam) semanticObject); 
				return; 
			case MD2Package.FLOAT_TYPE:
				sequence_AttributeType(context, (FloatType) semanticObject); 
				return; 
			case MD2Package.FLOAT_VAL:
				sequence_MathLiteral(context, (FloatVal) semanticObject); 
				return; 
			case MD2Package.FLOW_LAYOUT_PANE:
				sequence_FlowLayoutPane(context, (FlowLayoutPane) semanticObject); 
				return; 
			case MD2Package.FLOW_LAYOUT_PANE_FLOW_DIRECTION_PARAM:
				sequence_FlowLayoutPaneParam(context, (FlowLayoutPaneFlowDirectionParam) semanticObject); 
				return; 
			case MD2Package.GLOBAL_EVENT_REF:
				sequence_EventDef(context, (GlobalEventRef) semanticObject); 
				return; 
			case MD2Package.GOTO_VIEW_ACTION:
				sequence_SimpleAction(context, (GotoViewAction) semanticObject); 
				return; 
			case MD2Package.GRID_LAYOUT_PANE:
				sequence_GridLayoutPane(context, (GridLayoutPane) semanticObject); 
				return; 
			case MD2Package.GRID_LAYOUT_PANE_COLUMNS_PARAM:
				sequence_GridLayoutPaneParam(context, (GridLayoutPaneColumnsParam) semanticObject); 
				return; 
			case MD2Package.GRID_LAYOUT_PANE_ROWS_PARAM:
				sequence_GridLayoutPaneParam(context, (GridLayoutPaneRowsParam) semanticObject); 
				return; 
			case MD2Package.GUI_ELEMENT_STATE_EXPRESSION:
				sequence_ComplexConditionalExpression(context, (GuiElementStateExpression) semanticObject); 
				return; 
			case MD2Package.HEX_COLOR_DEF:
				sequence_Color(context, (HexColorDef) semanticObject); 
				return; 
			case MD2Package.IF_CODE_BLOCK:
				sequence_IfCodeBlock(context, (IfCodeBlock) semanticObject); 
				return; 
			case MD2Package.IMAGE:
				if(context == grammarAccess.getImageExtendedDefinitionRule()) {
					sequence_ImageExtendedDefinition(context, (Image) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getImageShorthandDefinitionRule()) {
					sequence_ImageShorthandDefinition(context, (Image) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getContentElementRule() ||
				   context == grammarAccess.getImageRule() ||
				   context == grammarAccess.getViewElementRule() ||
				   context == grammarAccess.getViewElementTypeRule() ||
				   context == grammarAccess.getViewGUIElementRule()) {
					sequence_Image_ImageExtendedDefinition_ImageShorthandDefinition(context, (Image) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.INT_VAL:
				sequence_MathLiteral(context, (IntVal) semanticObject); 
				return; 
			case MD2Package.INTEGER_INPUT:
				sequence_IntegerInput(context, (IntegerInput) semanticObject); 
				return; 
			case MD2Package.INTEGER_REST_PARAM:
				sequence_RESTValue(context, (IntegerRestParam) semanticObject); 
				return; 
			case MD2Package.INTEGER_TYPE:
				sequence_AttributeType(context, (IntegerType) semanticObject); 
				return; 
			case MD2Package.INVOKE_BOOLEAN_VALUE:
				sequence_InvokeValue(context, (InvokeBooleanValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_DATE_TIME_VALUE:
				sequence_InvokeValue(context, (InvokeDateTimeValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_DATE_VALUE:
				sequence_InvokeValue(context, (InvokeDateValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_DEFAULT_VALUE:
				sequence_InvokeParam(context, (InvokeDefaultValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_DEFINITION:
				sequence_InvokeDefinition(context, (InvokeDefinition) semanticObject); 
				return; 
			case MD2Package.INVOKE_FLOAT_VALUE:
				sequence_InvokeValue(context, (InvokeFloatValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_INT_VALUE:
				sequence_InvokeValue(context, (InvokeIntValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_SET_CONTENT_PROVIDER:
				sequence_InvokeParam(context, (InvokeSetContentProvider) semanticObject); 
				return; 
			case MD2Package.INVOKE_STRING_VALUE:
				sequence_InvokeValue(context, (InvokeStringValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_TIME_VALUE:
				sequence_InvokeValue(context, (InvokeTimeValue) semanticObject); 
				return; 
			case MD2Package.INVOKE_WS_PARAM:
				sequence_InvokeParam(context, (InvokeWSParam) semanticObject); 
				return; 
			case MD2Package.LABEL:
				if(context == grammarAccess.getLabelExtendedDefinitionRule()) {
					sequence_LabelExtendedDefinition(context, (Label) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLabelShorthandDefinitionRule()) {
					sequence_LabelShorthandDefinition(context, (Label) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getContentElementRule() ||
				   context == grammarAccess.getLabelRule() ||
				   context == grammarAccess.getMappableContentElementRule() ||
				   context == grammarAccess.getViewElementRule() ||
				   context == grammarAccess.getViewElementTypeRule() ||
				   context == grammarAccess.getViewGUIElementRule()) {
					sequence_Label_LabelExtendedDefinition_LabelShorthandDefinition(context, (Label) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.LOCATION_ACTION:
				sequence_SimpleAction(context, (LocationAction) semanticObject); 
				return; 
			case MD2Package.LOCATION_PROVIDER_PATH:
				sequence_LocationProviderPath(context, (LocationProviderPath) semanticObject); 
				return; 
			case MD2Package.LOCATION_PROVIDER_REFERENCE:
				sequence_ComplexConditionalExpression_EventDef_CompareExpression_1_1_ContentProviderEventRef_1_1(context, (LocationProviderReference) semanticObject); 
				return; 
			case MD2Package.MD2_MODEL:
				sequence_MD2Model(context, (MD2Model) semanticObject); 
				return; 
			case MD2Package.MAIN:
				sequence_Main(context, (Main) semanticObject); 
				return; 
			case MD2Package.MAPPING_TASK:
				sequence_CustomCodeFragment(context, (MappingTask) semanticObject); 
				return; 
			case MD2Package.MINUS:
				sequence_AdditionSubtraction(context, (Minus) semanticObject); 
				return; 
			case MD2Package.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MD2Package.MULT:
				sequence_MultiplicationDivision(context, (Mult) semanticObject); 
				return; 
			case MD2Package.NAMED_COLOR_DEF:
				sequence_Color(context, (NamedColorDef) semanticObject); 
				return; 
			case MD2Package.NOT:
				sequence_ConditionalExpression(context, (Not) semanticObject); 
				return; 
			case MD2Package.NOT_NULL_VALIDATOR:
				sequence_Validator(context, (NotNullValidator) semanticObject); 
				return; 
			case MD2Package.NUMBER_INPUT:
				sequence_NumberInput(context, (NumberInput) semanticObject); 
				return; 
			case MD2Package.NUMBER_RANGE_VALIDATOR:
				sequence_Validator(context, (NumberRangeValidator) semanticObject); 
				return; 
			case MD2Package.ON_CONDITION_EVENT:
				sequence_OnConditionEvent(context, (OnConditionEvent) semanticObject); 
				return; 
			case MD2Package.OPTION_INPUT:
				sequence_OptionInput(context, (OptionInput) semanticObject); 
				return; 
			case MD2Package.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MD2Package.PACKAGE_DEFINITION:
				sequence_PackageDefinition(context, (PackageDefinition) semanticObject); 
				return; 
			case MD2Package.PATH_TAIL:
				sequence_PathTail(context, (PathTail) semanticObject); 
				return; 
			case MD2Package.PLUS:
				sequence_AdditionSubtraction(context, (Plus) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN:
				sequence_ProcessChain(context, (ProcessChain) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GO_TO_DEFINITION:
				sequence_ProcessChainGoToDefinition(context, (ProcessChainGoToDefinition) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GO_TO_NEXT:
				sequence_ProcessChainGoTo(context, (ProcessChainGoToNext) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GO_TO_PREVIOUS:
				sequence_ProcessChainGoTo(context, (ProcessChainGoToPrevious) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GO_TO_SPEC_EXTENDED:
				sequence_ProcessChainGoToSpec(context, (ProcessChainGoToSpecExtended) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GO_TO_SPEC_SHORTHAND:
				sequence_ProcessChainGoToSpec(context, (ProcessChainGoToSpecShorthand) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GO_TO_STEP:
				sequence_ProcessChainGoTo(context, (ProcessChainGoToStep) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_GOTO_ACTION:
				sequence_SimpleAction(context, (ProcessChainGotoAction) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_PROCEED_ACTION:
				sequence_SimpleAction(context, (ProcessChainProceedAction) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_RETURN:
				sequence_ProcessChainGoTo(context, (ProcessChainReturn) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_REVERSE_ACTION:
				sequence_SimpleAction(context, (ProcessChainReverseAction) semanticObject); 
				return; 
			case MD2Package.PROCESS_CHAIN_STEP:
				sequence_ProcessChainStep(context, (ProcessChainStep) semanticObject); 
				return; 
			case MD2Package.REST_PARAM:
				sequence_RESTParam(context, (RESTParam) semanticObject); 
				return; 
			case MD2Package.REFERENCED_MODEL_TYPE:
				sequence_DataType(context, (ReferencedModelType) semanticObject); 
				return; 
			case MD2Package.REFERENCED_TYPE:
				sequence_AttributeType(context, (ReferencedType) semanticObject); 
				return; 
			case MD2Package.REG_EX_VALIDATOR:
				sequence_Validator(context, (RegExValidator) semanticObject); 
				return; 
			case MD2Package.REMOTE_CONNECTION:
				sequence_RemoteConnection(context, (RemoteConnection) semanticObject); 
				return; 
			case MD2Package.REMOTE_VALIDATOR:
				sequence_RemoteValidator(context, (RemoteValidator) semanticObject); 
				return; 
			case MD2Package.SET_PROCESS_CHAIN_ACTION:
				sequence_SimpleAction(context, (SetProcessChainAction) semanticObject); 
				return; 
			case MD2Package.SIMPLE_ACTION_REF:
				sequence_ActionDef(context, (SimpleActionRef) semanticObject); 
				return; 
			case MD2Package.SIMPLE_DATA_TYPE_WRAPPER:
				sequence_SimpleDataTypeWrapper(context, (SimpleDataTypeWrapper) semanticObject); 
				return; 
			case MD2Package.SIMPLE_TYPE:
				sequence_DataType(context, (SimpleType) semanticObject); 
				return; 
			case MD2Package.SPACER:
				sequence_Spacer(context, (Spacer) semanticObject); 
				return; 
			case MD2Package.STANDARD_DATE_RANGE_VALIDATOR:
				sequence_StandardValidator(context, (StandardDateRangeValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_DATE_TIME_RANGE_VALIDATOR:
				sequence_StandardValidator(context, (StandardDateTimeRangeValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_NOT_NULL_VALIDATOR:
				sequence_StandardValidator(context, (StandardNotNullValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_NUMBER_RANGE_VALIDATOR:
				sequence_StandardValidator(context, (StandardNumberRangeValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_REG_EX_VALIDATOR:
				sequence_StandardValidator(context, (StandardRegExValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_STRING_RANGE_VALIDATOR:
				sequence_StandardValidator(context, (StandardStringRangeValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_TIME_RANGE_VALIDATOR:
				sequence_StandardValidator(context, (StandardTimeRangeValidator) semanticObject); 
				return; 
			case MD2Package.STANDARD_VALIDATOR_TYPE:
				sequence_ValidatorType(context, (StandardValidatorType) semanticObject); 
				return; 
			case MD2Package.STRING_RANGE_VALIDATOR:
				sequence_Validator(context, (StringRangeValidator) semanticObject); 
				return; 
			case MD2Package.STRING_REST_PARAM:
				sequence_RESTValue(context, (StringRestParam) semanticObject); 
				return; 
			case MD2Package.STRING_TYPE:
				sequence_AttributeType(context, (StringType) semanticObject); 
				return; 
			case MD2Package.STRING_VAL:
				sequence_StringPartial(context, (StringVal) semanticObject); 
				return; 
			case MD2Package.STYLE:
				sequence_Style(context, (Style) semanticObject); 
				return; 
			case MD2Package.STYLE_BODY:
				sequence_StyleBody(context, (StyleBody) semanticObject); 
				return; 
			case MD2Package.STYLE_DEFINITION:
				sequence_StyleAssignment(context, (StyleDefinition) semanticObject); 
				return; 
			case MD2Package.STYLE_REFERENCE:
				sequence_StyleAssignment(context, (StyleReference) semanticObject); 
				return; 
			case MD2Package.TAB_ICON_PARAM:
				sequence_TabSpecificParam(context, (TabIconParam) semanticObject); 
				return; 
			case MD2Package.TAB_TITLE_PARAM:
				sequence_TabSpecificParam(context, (TabTitleParam) semanticObject); 
				return; 
			case MD2Package.TABBED_ALTERNATIVES_PANE:
				sequence_TabbedAlternativesPane(context, (TabbedAlternativesPane) semanticObject); 
				return; 
			case MD2Package.TEXT_INPUT:
				sequence_TextInput(context, (TextInput) semanticObject); 
				return; 
			case MD2Package.TIME_INPUT:
				sequence_TimeInput(context, (TimeInput) semanticObject); 
				return; 
			case MD2Package.TIME_RANGE_VALIDATOR:
				sequence_Validator(context, (TimeRangeValidator) semanticObject); 
				return; 
			case MD2Package.TIME_TYPE:
				sequence_AttributeType(context, (TimeType) semanticObject); 
				return; 
			case MD2Package.TIME_VAL:
				sequence_StringPartial(context, (TimeVal) semanticObject); 
				return; 
			case MD2Package.TOOLTIP:
				if(context == grammarAccess.getTooltipExtendedDefinitionRule()) {
					sequence_TooltipExtendedDefinition(context, (Tooltip) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getTooltipShorthandDefinitionRule()) {
					sequence_TooltipShorthandDefinition(context, (Tooltip) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getContentElementRule() ||
				   context == grammarAccess.getMappableContentElementRule() ||
				   context == grammarAccess.getTooltipRule() ||
				   context == grammarAccess.getViewElementRule() ||
				   context == grammarAccess.getViewElementTypeRule() ||
				   context == grammarAccess.getViewGUIElementRule()) {
					sequence_Tooltip_TooltipExtendedDefinition_TooltipShorthandDefinition(context, (Tooltip) semanticObject); 
					return; 
				}
				else break;
			case MD2Package.UNMAPPING_TASK:
				sequence_CustomCodeFragment(context, (UnmappingTask) semanticObject); 
				return; 
			case MD2Package.UPLOADED_IMAGE_OUTPUT:
				sequence_UploadedImageOutput(context, (UploadedImageOutput) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_BINDING_TASK:
				sequence_CustomCodeFragment(context, (ValidatorBindingTask) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MAX_DATE_PARAM:
				sequence_DateRangeValidatorParam(context, (ValidatorMaxDateParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MAX_DATE_TIME_PARAM:
				sequence_DateTimeRangeValidatorParam(context, (ValidatorMaxDateTimeParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MAX_LENGTH_PARAM:
				sequence_StringRangeValidatorParam(context, (ValidatorMaxLengthParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MAX_PARAM:
				sequence_NumberRangeValidatorParam(context, (ValidatorMaxParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MAX_TIME_PARAM:
				sequence_TimeRangeValidatorParam(context, (ValidatorMaxTimeParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MESSAGE_PARAM:
				sequence_ValidatorMessageParam(context, (ValidatorMessageParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MIN_DATE_PARAM:
				sequence_DateRangeValidatorParam(context, (ValidatorMinDateParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MIN_DATE_TIME_PARAM:
				sequence_DateTimeRangeValidatorParam(context, (ValidatorMinDateTimeParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MIN_LENGTH_PARAM:
				sequence_StringRangeValidatorParam(context, (ValidatorMinLengthParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MIN_PARAM:
				sequence_NumberRangeValidatorParam(context, (ValidatorMinParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_MIN_TIME_PARAM:
				sequence_TimeRangeValidatorParam(context, (ValidatorMinTimeParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_REG_EX_PARAM:
				sequence_RegExValidatorParam(context, (ValidatorRegExParam) semanticObject); 
				return; 
			case MD2Package.VALIDATOR_UNBIND_TASK:
				sequence_CustomCodeFragment(context, (ValidatorUnbindTask) semanticObject); 
				return; 
			case MD2Package.VIEW:
				sequence_View(context, (View) semanticObject); 
				return; 
			case MD2Package.VIEW_ELEMENT_EVENT_REF:
				sequence_EventDef(context, (ViewElementEventRef) semanticObject); 
				return; 
			case MD2Package.VIEW_ELEMENT_SET_TASK:
				sequence_CustomCodeFragment(context, (ViewElementSetTask) semanticObject); 
				return; 
			case MD2Package.VIEW_GUI_ELEMENT_REFERENCE:
				sequence_ViewGUIElementReference(context, (ViewGUIElementReference) semanticObject); 
				return; 
			case MD2Package.WEB_SERVICE_CALL:
				sequence_WebServiceCall(context, (WebServiceCall) semanticObject); 
				return; 
			case MD2Package.WEB_SERVICE_CALL_ACTION:
				sequence_SimpleAction(context, (WebServiceCallAction) semanticObject); 
				return; 
			case MD2Package.WHERE_CLAUSE_AND:
				sequence_WhereClauseAnd(context, (WhereClauseAnd) semanticObject); 
				return; 
			case MD2Package.WHERE_CLAUSE_COMPARE_EXPRESSION:
				sequence_WhereClauseConditionalExpression(context, (WhereClauseCompareExpression) semanticObject); 
				return; 
			case MD2Package.WHERE_CLAUSE_NOT:
				sequence_WhereClauseConditionalExpression(context, (WhereClauseNot) semanticObject); 
				return; 
			case MD2Package.WHERE_CLAUSE_OR:
				sequence_WhereClauseOr(context, (WhereClauseOr) semanticObject); 
				return; 
			case MD2Package.WIDTH_PARAM:
				sequence_CommonContainerParam(context, (WidthParam) semanticObject); 
				return; 
			case MD2Package.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			case MD2Package.WORKFLOW_ELEMENT:
				sequence_WorkflowElement(context, (WorkflowElement) semanticObject); 
				return; 
			case MD2Package.WORKFLOW_ELEMENT_ENTRY:
				sequence_WorkflowElementEntry(context, (WorkflowElementEntry) semanticObject); 
				return; 
			case MD2Package.WORKFLOW_ELEMENT_REFERENCE:
				sequence_WorkflowElementReference(context, (WorkflowElementReference) semanticObject); 
				return; 
			case MD2Package.WORKFLOW_EVENT:
				sequence_WorkflowEvent(context, (WorkflowEvent) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (ref=[ViewElementType|QUALIFIED_NAME] (tail=NestedAbstractViewGUIElementRef | path=EntityPath | simpleType=SimpleDataTypeWrapper)?)
	 */
	protected void sequence_AbstractViewGUIElementRef(EObject context, AbstractViewGUIElementRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     actionRef=[Action|QUALIFIED_NAME]
	 */
	protected void sequence_ActionDef(EObject context, ActionReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getActionReference_ActionRef()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getActionReference_ActionRef()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getActionDefAccess().getActionRefActionQUALIFIED_NAMEParserRuleCall_0_1_0_1(), semanticObject.getActionRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     action=SimpleAction
	 */
	protected void sequence_ActionDef(EObject context, SimpleActionRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getSimpleActionRef_Action()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getSimpleActionRef_Action()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getActionDefAccess().getActionSimpleActionParserRuleCall_1_1_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=AdditionSubtraction_Minus_1_0_1_0 rightOperand=MultiplicationDivision)
	 */
	protected void sequence_AdditionSubtraction(EObject context, Minus semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getMinus_LeftOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getMinus_LeftOperand()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getMinus_RightOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getMinus_RightOperand()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getMinusLeftOperandAction_1_0_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getRightOperandMultiplicationDivisionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=AdditionSubtraction_Plus_1_0_0_0 rightOperand=MultiplicationDivision)
	 */
	protected void sequence_AdditionSubtraction(EObject context, Plus semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getPlus_LeftOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getPlus_LeftOperand()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getPlus_RightOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getPlus_RightOperand()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getPlusLeftOperandAction_1_0_0_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getAdditionSubtractionAccess().getRightOperandMultiplicationDivisionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID (params+=CommonContainerParam params+=CommonContainerParam*)? elements+=ContainerElementType*)
	 */
	protected void sequence_AlternativesPane(EObject context, AlternativesPane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpression=And_And_1_0 rightExpression=ConditionalExpression)
	 */
	protected void sequence_And(EObject context, And semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAnd_LeftExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAnd_LeftExpression()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAnd_RightExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAnd_RightExpression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftExpressionAction_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getAndAccess().getRightExpressionConditionalExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         workflowElements+=WorkflowElementReference 
	 *         workflowElements+=WorkflowElementReference* 
	 *         appName=STRING 
	 *         defaultConnection=[RemoteConnection|ID]?
	 *     )
	 */
	protected void sequence_App(EObject context, App semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional' | 
	 *         optional?='optional'
	 *     )
	 */
	protected void sequence_AttributeTypeParam_BooleanTypeParam_DateTimeTypeParam_DateTypeParam_EnumTypeParam_FileTypeParam_FloatTypeParam_IntegerTypeParam_ReferencedTypeParam_StringTypeParam_TimeTypeParam(EObject context, AttrIsOptional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | value=STRING)
	 */
	protected void sequence_AttributeTypeParam_EnumTypeParam_ReferencedTypeParam(EObject context, AttrEnumDefault semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (identifier?='identifier' | identifier?='identifier')
	 */
	protected void sequence_AttributeTypeParam_IntegerTypeParam_StringTypeParam(EObject context, AttrIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=BooleanTypeParam params+=BooleanTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=DateTimeTypeParam params+=DateTimeTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, DateTimeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=DateTypeParam params+=DateTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, DateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enumBody=EnumBody? many?=BRACKETS? (params+=EnumTypeParam params+=EnumTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, EnumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=FileTypeParam params+=FileTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, FileType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=FloatTypeParam params+=FloatTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, FloatType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=IntegerTypeParam params+=IntegerTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, IntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (element=[ModelElement|QUALIFIED_NAME] many?=BRACKETS? (params+=ReferencedTypeParam params+=ReferencedTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, ReferencedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=StringTypeParam params+=StringTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (many?=BRACKETS? (params+=TimeTypeParam params+=TimeTypeParam*)?)
	 */
	protected void sequence_AttributeType(EObject context, TimeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID type=AttributeType (extendedName=STRING? description=STRING?)?)
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID width=PERCENT? isDisabled?='true'? contentProvider+=ContentProviderReference+ (exclude?='exclude'? filteredAttributes+=EntityPath+)?)
	 */
	protected void sequence_AutoGeneratedContentElement(EObject context, AutoGeneratedContentElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=BooleanInputType? 
	 *             isDisabled?='true'? 
	 *             (defaultValue='true' | defaultValue='false')? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_BooleanInput(EObject context, BooleanInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_BooleanTypeParam(EObject context, AttrBooleanDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrBooleanDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrBooleanDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanTypeParamAccess().getValueBooleanEnumRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_BooleanTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID text=STRING style=StyleAssignment? isDisabled?='true'? width=PERCENT?)
	 */
	protected void sequence_ButtonExtendedDefinition(EObject context, Button semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID text=STRING (style=StyleAssignment? isDisabled?='true'? width=PERCENT?)?)
	 */
	protected void sequence_ButtonShorthandDefinition(EObject context, Button semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (name=EID text=STRING (style=StyleAssignment? isDisabled?='true'? width=PERCENT?)?) | 
	 *         (name=EID text=STRING style=StyleAssignment? isDisabled?='true'? width=PERCENT?)
	 *     )
	 */
	protected void sequence_Button_ButtonExtendedDefinition_ButtonShorthandDefinition(EObject context, Button semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     color=HEX_COLOR
	 */
	protected void sequence_Color(EObject context, HexColorDef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getHexColorDef_Color()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getHexColorDef_Color()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getColorAccess().getColorHEX_COLORTerminalRuleCall_0_1_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     color=NamedColor
	 */
	protected void sequence_Color(EObject context, NamedColorDef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getNamedColorDef_Color()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getNamedColorDef_Color()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getColorAccess().getColorNamedColorEnumRuleCall_1_1_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID actions+=[Action|QUALIFIED_NAME]*)
	 */
	protected void sequence_CombinedAction(EObject context, CombinedAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     width=PERCENT
	 */
	protected void sequence_CommonContainerParam(EObject context, WidthParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWidthParam_Width()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWidthParam_Width()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCommonContainerParamAccess().getWidthPERCENTParserRuleCall_0_2_0(), semanticObject.getWidth());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (eqLeft=ComplexConditionalExpression_CompareExpression_1_1 op=Operator eqRight=SimpleExpression)
	 */
	protected void sequence_ComplexConditionalExpression(EObject context, CompareExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getCompareExpression_EqLeft()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getCompareExpression_EqLeft()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getCompareExpression_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getCompareExpression_Op()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getCompareExpression_EqRight()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getCompareExpression_EqRight()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComplexConditionalExpressionAccess().getCompareExpressionEqLeftAction_1_1(), semanticObject.getEqLeft());
		feeder.accept(grammarAccess.getComplexConditionalExpressionAccess().getOpOperatorEnumRuleCall_1_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComplexConditionalExpressionAccess().getEqRightSimpleExpressionParserRuleCall_1_3_0(), semanticObject.getEqRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {LocationProviderReference}
	 */
	protected void sequence_ComplexConditionalExpression_EventDef_CompareExpression_1_1_ContentProviderEventRef_1_1(EObject context, LocationProviderReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (reference=ComplexConditionalExpression_GuiElementStateExpression_0_1 isState=ViewElementState)
	 */
	protected void sequence_ComplexConditionalExpression(EObject context, GuiElementStateExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getGuiElementStateExpression_Reference()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getGuiElementStateExpression_Reference()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getGuiElementStateExpression_IsState()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getGuiElementStateExpression_IsState()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComplexConditionalExpressionAccess().getGuiElementStateExpressionReferenceAction_0_1(), semanticObject.getReference());
		feeder.accept(grammarAccess.getComplexConditionalExpressionAccess().getIsStateViewElementStateEnumRuleCall_0_2_0(), semanticObject.getIsState());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftString=ConcatenatedString_ConcatenatedString_1_0 rightString=StringPartial)
	 */
	protected void sequence_ConcatenatedString(EObject context, ConcatenatedString semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getConcatenatedString_LeftString()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getConcatenatedString_LeftString()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getConcatenatedString_RightString()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getConcatenatedString_RightString()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConcatenatedStringAccess().getConcatenatedStringLeftStringAction_1_0(), semanticObject.getLeftString());
		feeder.accept(grammarAccess.getConcatenatedStringAccess().getRightStringStringPartialParserRuleCall_1_2_0(), semanticObject.getRightString());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_ConditionalExpression(EObject context, BooleanExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getBooleanExpression_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getBooleanExpression_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getValueBooleanEnumRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=ConditionalExpression
	 */
	protected void sequence_ConditionalExpression(EObject context, Not semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getNot_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getNot_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionConditionalExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (value=[ContainerElement|QUALIFIED_NAME] (rename?='->' name=EID)? (params+=TabSpecificParam params+=TabSpecificParam*)?)
	 */
	protected void sequence_ContainerElementReference(EObject context, ContainerElementReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (contentProviderRef=[ContentProvider|ID] tail=PathTail)
	 */
	protected void sequence_ContentProviderPath(EObject context, ContentProviderPath semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getPathDefinition_Tail()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getPathDefinition_Tail()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderPath_ContentProviderRef()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderPath_ContentProviderRef()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getContentProviderPathAccess().getContentProviderRefContentProviderIDTerminalRuleCall_1_0_1(), semanticObject.getContentProviderRef());
		feeder.accept(grammarAccess.getContentProviderPathAccess().getTailPathTailParserRuleCall_2_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     contentProvider=[ContentProvider|QUALIFIED_NAME]
	 */
	protected void sequence_ContentProviderReference(EObject context, ContentProviderReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderReference_ContentProvider()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderReference_ContentProvider()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getContentProviderReferenceAccess().getContentProviderContentProviderQUALIFIED_NAMEParserRuleCall_1_0_1(), semanticObject.getContentProvider());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         type=DataType 
	 *         name=EID 
	 *         (default?='default' | local?='local' | connection=[RemoteConnection|ID]) 
	 *         (filter?='filter' filterType=FilterType whereClause=WhereClauseCondition?)? 
	 *         readonly?='true'?
	 *     )
	 */
	protected void sequence_ContentProvider(EObject context, ContentProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     controllerElements+=ControllerElement+
	 */
	protected void sequence_Controller(EObject context, Controller semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID codeFragments+=CustomCodeFragment*)
	 */
	protected void sequence_CustomAction(EObject context, CustomAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pathDefinition=CustomCodeFragment_AttributeSetTask_5_1_0_1 source=SimpleExpression)
	 */
	protected void sequence_CustomCodeFragment(EObject context, AttributeSetTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttributeSetTask_PathDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttributeSetTask_PathDefinition()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttributeSetTask_Source()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttributeSetTask_Source()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getAttributeSetTaskPathDefinitionAction_5_1_0_1(), semanticObject.getPathDefinition());
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getSourceSimpleExpressionParserRuleCall_5_1_0_3_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     action=ActionDef
	 */
	protected void sequence_CustomCodeFragment(EObject context, CallTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getCallTask_Action()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getCallTask_Action()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getActionActionDefParserRuleCall_2_1_1_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (if=IfCodeBlock elseifs+=IfCodeBlock* else=ElseCodeBlock?)
	 */
	protected void sequence_CustomCodeFragment(EObject context, ConditionalCodeFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (contentProvider=CustomCodeFragment_ContentProviderSetTask_5_1_1_1 source=SimpleExpression)
	 */
	protected void sequence_CustomCodeFragment(EObject context, ContentProviderSetTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderSetTask_ContentProvider()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderSetTask_ContentProvider()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderSetTask_Source()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderSetTask_Source()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getContentProviderSetTaskContentProviderAction_5_1_1_1(), semanticObject.getContentProvider());
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getSourceSimpleExpressionParserRuleCall_5_1_1_3_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (actions+=ActionDef+ events+=EventDef+)
	 */
	protected void sequence_CustomCodeFragment(EObject context, EventBindingTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (actions+=ActionDef+ events+=EventDef+)
	 */
	protected void sequence_CustomCodeFragment(EObject context, EventUnbindTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (referencedViewField=AbstractViewGUIElementRef pathDefinition=AbstractContentProviderPath)
	 */
	protected void sequence_CustomCodeFragment(EObject context, MappingTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getMappingTask_ReferencedViewField()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getMappingTask_ReferencedViewField()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getMappingTask_PathDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getMappingTask_PathDefinition()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getReferencedViewFieldAbstractViewGUIElementRefParserRuleCall_3_1_1_0(), semanticObject.getReferencedViewField());
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getPathDefinitionAbstractContentProviderPathParserRuleCall_3_1_3_0(), semanticObject.getPathDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (referencedViewField=AbstractViewGUIElementRef pathDefinition=AbstractContentProviderPath)
	 */
	protected void sequence_CustomCodeFragment(EObject context, UnmappingTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getUnmappingTask_ReferencedViewField()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getUnmappingTask_ReferencedViewField()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getUnmappingTask_PathDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getUnmappingTask_PathDefinition()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getReferencedViewFieldAbstractViewGUIElementRefParserRuleCall_4_1_1_0(), semanticObject.getReferencedViewField());
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getPathDefinitionAbstractContentProviderPathParserRuleCall_4_1_3_0(), semanticObject.getPathDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (validators+=ValidatorType+ referencedFields+=AbstractViewGUIElementRef+)
	 */
	protected void sequence_CustomCodeFragment(EObject context, ValidatorBindingTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((validators+=ValidatorType+ | allTypes?='all') referencedFields+=AbstractViewGUIElementRef+)
	 */
	protected void sequence_CustomCodeFragment(EObject context, ValidatorUnbindTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (referencedViewField=CustomCodeFragment_ViewElementSetTask_5_1_2_1 source=SimpleExpression)
	 */
	protected void sequence_CustomCodeFragment(EObject context, ViewElementSetTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getViewElementSetTask_ReferencedViewField()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getViewElementSetTask_ReferencedViewField()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getViewElementSetTask_Source()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getViewElementSetTask_Source()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getViewElementSetTaskReferencedViewFieldAction_5_1_2_1(), semanticObject.getReferencedViewField());
		feeder.accept(grammarAccess.getCustomCodeFragmentAccess().getSourceSimpleExpressionParserRuleCall_5_1_2_3_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (entity=[ModelElement|QUALIFIED_NAME] many?=BRACKETS?)
	 */
	protected void sequence_DataType(EObject context, ReferencedModelType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=SimpleDataType many?=BRACKETS?)
	 */
	protected void sequence_DataType(EObject context, SimpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=DateInputType? 
	 *             isDisabled?='true'? 
	 *             defaultValue=DATE? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_DateInput(EObject context, DateInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     max=DATE
	 */
	protected void sequence_DateRangeValidatorParam(EObject context, ValidatorMaxDateParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMaxDateParam_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMaxDateParam_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateRangeValidatorParamAccess().getMaxDATEParserRuleCall_1_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=DATE
	 */
	protected void sequence_DateRangeValidatorParam(EObject context, ValidatorMinDateParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMinDateParam_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMinDateParam_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateRangeValidatorParamAccess().getMinDATEParserRuleCall_2_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=DateTimeInputType? 
	 *             isDisabled?='true'? 
	 *             defaultValue=DATE_TIME? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_DateTimeInput(EObject context, DateTimeInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     max=DATE_TIME
	 */
	protected void sequence_DateTimeRangeValidatorParam(EObject context, ValidatorMaxDateTimeParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMaxDateTimeParam_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMaxDateTimeParam_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTimeRangeValidatorParamAccess().getMaxDATE_TIMEParserRuleCall_1_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=DATE_TIME
	 */
	protected void sequence_DateTimeRangeValidatorParam(EObject context, ValidatorMinDateTimeParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMinDateTimeParam_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMinDateTimeParam_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTimeRangeValidatorParamAccess().getMinDATE_TIMEParserRuleCall_2_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=DATE_TIME
	 */
	protected void sequence_DateTimeTypeParam(EObject context, AttrDateTimeDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrDateTimeDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrDateTimeDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTimeTypeParamAccess().getValueDATE_TIMEParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     max=DATE_TIME
	 */
	protected void sequence_DateTimeTypeParam(EObject context, AttrDateTimeMax semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrDateTimeMax_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrDateTimeMax_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTimeTypeParamAccess().getMaxDATE_TIMEParserRuleCall_2_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=DATE_TIME
	 */
	protected void sequence_DateTimeTypeParam(EObject context, AttrDateTimeMin semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrDateTimeMin_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrDateTimeMin_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTimeTypeParamAccess().getMinDATE_TIMEParserRuleCall_3_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_DateTimeTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTimeTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=DATE
	 */
	protected void sequence_DateTypeParam(EObject context, AttrDateDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrDateDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrDateDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTypeParamAccess().getValueDATEParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     max=DATE
	 */
	protected void sequence_DateTypeParam(EObject context, AttrDateMax semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrDateMax_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrDateMax_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTypeParamAccess().getMaxDATEParserRuleCall_2_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=DATE
	 */
	protected void sequence_DateTypeParam(EObject context, AttrDateMin semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrDateMin_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrDateMin_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTypeParamAccess().getMinDATEParserRuleCall_3_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_DateTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (codeFragments+=CustomCodeFragment*)
	 */
	protected void sequence_ElseCodeBlock(EObject context, ElseCodeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (entityRef=[Entity|ID] tail=PathTail)
	 */
	protected void sequence_EntityPath(EObject context, EntityPath semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getPathDefinition_Tail()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getPathDefinition_Tail()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getEntityPath_EntityRef()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getEntityPath_EntityRef()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEntityPathAccess().getEntityRefEntityIDTerminalRuleCall_0_0_1(), semanticObject.getEntityRef());
		feeder.accept(grammarAccess.getEntityPathAccess().getTailPathTailParserRuleCall_1_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         labelText=STRING? 
	 *         tooltipText=STRING? 
	 *         isDisabled?='true'? 
	 *         width=PERCENT? 
	 *         textProposition=ContentProviderPath
	 *     )
	 */
	protected void sequence_EntitySelector(EObject context, EntitySelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID attributes+=Attribute*)
	 */
	protected void sequence_Entity(EObject context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=STRING elements+=STRING*)
	 */
	protected void sequence_EnumBody(EObject context, EnumBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_EnumTypeParam(EObject context, AttrEnumDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrEnumDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrEnumDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEnumTypeParamAccess().getValueSTRINGTerminalRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_EnumTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEnumTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID enumBody=EnumBody?)
	 */
	protected void sequence_Enum(EObject context, de.wwu.md2.framework.mD2.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     eventReference=[OnConditionEvent|QUALIFIED_NAME]
	 */
	protected void sequence_EventDef(EObject context, ConditionalEventRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getConditionalEventRef_EventReference()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getConditionalEventRef_EventReference()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventDefAccess().getEventReferenceOnConditionEventQUALIFIED_NAMEParserRuleCall_4_1_0_1(), semanticObject.getEventReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (contentProvider=EventDef_ContentProviderEventRef_1_1 event=ContentProviderEventType)
	 */
	protected void sequence_EventDef(EObject context, ContentProviderEventRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderEventRef_ContentProvider()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderEventRef_ContentProvider()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderEventRef_Event()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderEventRef_Event()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventDefAccess().getContentProviderEventRefContentProviderAction_1_1(), semanticObject.getContentProvider());
		feeder.accept(grammarAccess.getEventDefAccess().getEventContentProviderEventTypeEnumRuleCall_1_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (pathDefinition=EventDef_ContentProviderPathEventRef_0_1 event=ContentProviderEventType)
	 */
	protected void sequence_EventDef(EObject context, ContentProviderPathEventRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderPathEventRef_PathDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderPathEventRef_PathDefinition()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderPathEventRef_Event()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderPathEventRef_Event()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventDefAccess().getContentProviderPathEventRefPathDefinitionAction_0_1(), semanticObject.getPathDefinition());
		feeder.accept(grammarAccess.getEventDefAccess().getEventContentProviderEventTypeEnumRuleCall_0_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     event=GlobalEventType
	 */
	protected void sequence_EventDef(EObject context, GlobalEventRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getGlobalEventRef_Event()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getGlobalEventRef_Event()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventDefAccess().getEventGlobalEventTypeEnumRuleCall_3_1_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (referencedField=AbstractViewGUIElementRef event=ElementEventType)
	 */
	protected void sequence_EventDef(EObject context, ViewElementEventRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getViewElementEventRef_ReferencedField()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getViewElementEventRef_ReferencedField()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getViewElementEventRef_Event()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getViewElementEventRef_Event()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventDefAccess().getReferencedFieldAbstractViewGUIElementRefParserRuleCall_2_1_0(), semanticObject.getReferencedField());
		feeder.accept(grammarAccess.getEventDefAccess().getEventElementEventTypeEnumRuleCall_2_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_FileTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFileTypeParamAccess().getOptionalOptionalKeyword_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             isDisabled?='true'? 
	 *             style=StyleAssignment? 
	 *             width=PERCENT? 
	 *             buttonValueText=STRING?
	 *         )?
	 *     )
	 */
	protected void sequence_FileUpload(EObject context, FileUpload semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (event=[WorkflowEvent|ID] (startedWorkflowElement=[WorkflowElement|ID] | endWorkflow?='workflow'))
	 */
	protected void sequence_FireEventEntry(EObject context, FireEventEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatTypeParam(EObject context, AttrFloatDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrFloatDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrFloatDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFloatTypeParamAccess().getValueFLOATParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     max=FLOAT
	 */
	protected void sequence_FloatTypeParam(EObject context, AttrFloatMax semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrFloatMax_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrFloatMax_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFloatTypeParamAccess().getMaxFLOATParserRuleCall_2_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=FLOAT
	 */
	protected void sequence_FloatTypeParam(EObject context, AttrFloatMin semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrFloatMin_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrFloatMin_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFloatTypeParamAccess().getMinFLOATParserRuleCall_3_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_FloatTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFloatTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     flowDirection=FlowDirection
	 */
	protected void sequence_FlowLayoutPaneParam(EObject context, FlowLayoutPaneFlowDirectionParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getFlowLayoutPaneFlowDirectionParam_FlowDirection()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getFlowLayoutPaneFlowDirectionParam_FlowDirection()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFlowLayoutPaneParamAccess().getFlowDirectionFlowDirectionEnumRuleCall_0_1_0(), semanticObject.getFlowDirection());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID (params+=FlowLayoutPaneParam params+=FlowLayoutPaneParam*)? elements+=ViewElementType*)
	 */
	protected void sequence_FlowLayoutPane(EObject context, FlowLayoutPane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_GridLayoutPaneParam(EObject context, GridLayoutPaneColumnsParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getGridLayoutPaneColumnsParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getGridLayoutPaneColumnsParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGridLayoutPaneParamAccess().getValueINTTerminalRuleCall_0_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_GridLayoutPaneParam(EObject context, GridLayoutPaneRowsParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getGridLayoutPaneRowsParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getGridLayoutPaneRowsParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGridLayoutPaneParamAccess().getValueINTTerminalRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=GridLayoutPaneParam params+=GridLayoutPaneParam* elements+=ViewElementType*)
	 */
	protected void sequence_GridLayoutPane(EObject context, GridLayoutPane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Condition codeFragments+=CustomCodeFragment*)
	 */
	protected void sequence_IfCodeBlock(EObject context, IfCodeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID src=STRING height=INT? width=INT?)
	 */
	protected void sequence_ImageExtendedDefinition(EObject context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID src=STRING (imgHeight=INT? imgWidth=INT? width=PERCENT?)?)
	 */
	protected void sequence_ImageShorthandDefinition(EObject context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=EID src=STRING (imgHeight=INT? imgWidth=INT? width=PERCENT?)?) | (name=EID src=STRING height=INT? width=INT?))
	 */
	protected void sequence_Image_ImageExtendedDefinition_ImageShorthandDefinition(EObject context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=IntegerInputType? 
	 *             isDisabled?='true'? 
	 *             defaultValue=INT? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_IntegerInput(EObject context, IntegerInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     identifier?='identifier'
	 */
	protected void sequence_IntegerTypeParam(EObject context, AttrIdentifier semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIdentifier_Identifier()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIdentifier_Identifier()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerTypeParamAccess().getIdentifierIdentifierKeyword_1_1_0(), semanticObject.isIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerTypeParam(EObject context, AttrIntDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIntDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIntDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerTypeParamAccess().getValueINTTerminalRuleCall_2_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     max=INT
	 */
	protected void sequence_IntegerTypeParam(EObject context, AttrIntMax semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIntMax_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIntMax_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerTypeParamAccess().getMaxINTTerminalRuleCall_3_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=INT
	 */
	protected void sequence_IntegerTypeParam(EObject context, AttrIntMin semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIntMin_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIntMin_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerTypeParamAccess().getMinINTTerminalRuleCall_4_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_IntegerTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (path=STRING? method=RESTMethod? params+=InvokeParam*)
	 */
	protected void sequence_InvokeDefinition(EObject context, InvokeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (field=ContentProviderPath invokeValue=InvokeValue)
	 */
	protected void sequence_InvokeParam(EObject context, InvokeDefaultValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeParam_Field()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeParam_Field()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeDefaultValue_InvokeValue()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeDefaultValue_InvokeValue()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeParamAccess().getFieldContentProviderPathParserRuleCall_1_2_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getInvokeParamAccess().getInvokeValueInvokeValueParserRuleCall_1_4_0(), semanticObject.getInvokeValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (field=ContentProviderPath contentProvider=ContentProviderReference)
	 */
	protected void sequence_InvokeParam(EObject context, InvokeSetContentProvider semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeParam_Field()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeParam_Field()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeSetContentProvider_ContentProvider()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeSetContentProvider_ContentProvider()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeParamAccess().getFieldContentProviderPathParserRuleCall_2_2_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getInvokeParamAccess().getContentProviderContentProviderReferenceParserRuleCall_2_4_0(), semanticObject.getContentProvider());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (field=ContentProviderPath alias=EID?)
	 */
	protected void sequence_InvokeParam(EObject context, InvokeWSParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_InvokeValue(EObject context, InvokeBooleanValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeBooleanValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeBooleanValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueBooleanEnumRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=DATE_TIME
	 */
	protected void sequence_InvokeValue(EObject context, InvokeDateTimeValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeDateTimeValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeDateTimeValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueDATE_TIMEParserRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=DATE
	 */
	protected void sequence_InvokeValue(EObject context, InvokeDateValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeDateValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeDateValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueDATEParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_InvokeValue(EObject context, InvokeFloatValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeFloatValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeFloatValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueFLOATParserRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_InvokeValue(EObject context, InvokeIntValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeIntValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeIntValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_InvokeValue(EObject context, InvokeStringValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeStringValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeStringValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=TIME
	 */
	protected void sequence_InvokeValue(EObject context, InvokeTimeValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getInvokeTimeValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getInvokeTimeValue_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInvokeValueAccess().getValueTIMEParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID text=STRING style=StyleAssignment? width=PERCENT?)
	 */
	protected void sequence_LabelExtendedDefinition(EObject context, Label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID text=STRING (style=StyleAssignment? width=PERCENT?)?)
	 */
	protected void sequence_LabelShorthandDefinition(EObject context, Label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=EID text=STRING (style=StyleAssignment? width=PERCENT?)?) | (name=EID text=STRING style=StyleAssignment? width=PERCENT?))
	 */
	protected void sequence_Label_LabelExtendedDefinition_LabelShorthandDefinition(EObject context, Label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     locationField=LocationField
	 */
	protected void sequence_LocationProviderPath(EObject context, LocationProviderPath semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getLocationProviderPath_LocationField()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getLocationProviderPath_LocationField()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLocationProviderPathAccess().getLocationFieldLocationFieldEnumRuleCall_3_0(), semanticObject.getLocationField());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (package=PackageDefinition modelLayer=MD2ModelLayer?)
	 */
	protected void sequence_MD2Model(EObject context, MD2Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         appVersion=STRING 
	 *         modelVersion=STRING 
	 *         workflowManager=[RemoteConnection|ID] 
	 *         defaultConnection=[RemoteConnection|ID]? 
	 *         fileUploadConnection=[RemoteConnection|ID]?
	 *     )
	 */
	protected void sequence_Main(EObject context, Main semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_MathLiteral(EObject context, FloatVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getFloatVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getFloatVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMathLiteralAccess().getValueFLOATParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_MathLiteral(EObject context, IntVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getIntVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getIntVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMathLiteralAccess().getValueINTTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     modelElements+=ModelElement+
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=MultiplicationDivision_Div_1_0_1_0 rightOperand=MathSubExpression)
	 */
	protected void sequence_MultiplicationDivision(EObject context, Div semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getDiv_LeftOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getDiv_LeftOperand()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getDiv_RightOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getDiv_RightOperand()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getDivLeftOperandAction_1_0_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getRightOperandMathSubExpressionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=MultiplicationDivision_Mult_1_0_0_0 rightOperand=MathSubExpression)
	 */
	protected void sequence_MultiplicationDivision(EObject context, Mult semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getMult_LeftOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getMult_LeftOperand()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getMult_RightOperand()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getMult_RightOperand()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getMultLeftOperandAction_1_0_0_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getMultiplicationDivisionAccess().getRightOperandMathSubExpressionParserRuleCall_1_1_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ref=[ViewElementType|QUALIFIED_NAME] (tail=NestedAbstractViewGUIElementRef | path=EntityPath | simpleType=SimpleDataTypeWrapper)?)
	 */
	protected void sequence_NestedAbstractViewGUIElementRef(EObject context, AbstractViewGUIElementRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=NumberInputType? 
	 *             isDisabled?='true'? 
	 *             (placesSet?='places' places=INT)? 
	 *             defaultValue=FLOAT? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_NumberInput(EObject context, NumberInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     max=FLOAT
	 */
	protected void sequence_NumberRangeValidatorParam(EObject context, ValidatorMaxParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMaxParam_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMaxParam_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNumberRangeValidatorParamAccess().getMaxFLOATParserRuleCall_1_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=FLOAT
	 */
	protected void sequence_NumberRangeValidatorParam(EObject context, ValidatorMinParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMinParam_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMinParam_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNumberRangeValidatorParamAccess().getMinFLOATParserRuleCall_2_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID condition=Condition)
	 */
	protected void sequence_OnConditionEvent(EObject context, OnConditionEvent semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getOnConditionEvent_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getOnConditionEvent_Name()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getOnConditionEvent_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getOnConditionEvent_Condition()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOnConditionEventAccess().getNameEIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOnConditionEventAccess().getConditionConditionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=OptionInputType? 
	 *             isDisabled?='true'? 
	 *             defaultValue=STRING? 
	 *             width=PERCENT? 
	 *             (enumReference=[Enum|ID] | enumBody=EnumBody?)?
	 *         )?
	 *     )
	 */
	protected void sequence_OptionInput(EObject context, OptionInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpression=Or_Or_1_0 rightExpression=And)
	 */
	protected void sequence_Or(EObject context, Or semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getOr_LeftExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getOr_LeftExpression()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getOr_RightExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getOr_RightExpression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftExpressionAction_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getOrAccess().getRightExpressionAndParserRuleCall_1_2_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     pkgName=QUALIFIED_NAME
	 */
	protected void sequence_PackageDefinition(EObject context, PackageDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getPackageDefinition_PkgName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getPackageDefinition_PkgName()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPackageDefinitionAccess().getPkgNameQUALIFIED_NAMEParserRuleCall_1_0(), semanticObject.getPkgName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attributeRef=[Attribute|ID] tail=PathTail?)
	 */
	protected void sequence_PathTail(EObject context, PathTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (goto=ProcessChainGoTo spec=ProcessChainGoToSpec)
	 */
	protected void sequence_ProcessChainGoToDefinition(EObject context, ProcessChainGoToDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getProcessChainGoToDefinition_Goto()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getProcessChainGoToDefinition_Goto()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getProcessChainGoToDefinition_Spec()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getProcessChainGoToDefinition_Spec()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProcessChainGoToDefinitionAccess().getGotoProcessChainGoToParserRuleCall_0_0(), semanticObject.getGoto());
		feeder.accept(grammarAccess.getProcessChainGoToDefinitionAccess().getSpecProcessChainGoToSpecParserRuleCall_1_0(), semanticObject.getSpec());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (events+=EventDef* (condition=Condition | condition=Condition)? action=ActionDef?)
	 */
	protected void sequence_ProcessChainGoToSpec(EObject context, ProcessChainGoToSpecExtended semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (events+=EventDef*)
	 */
	protected void sequence_ProcessChainGoToSpec(EObject context, ProcessChainGoToSpecShorthand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ProcessChainGoToNext}
	 */
	protected void sequence_ProcessChainGoTo(EObject context, ProcessChainGoToNext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ProcessChainGoToPrevious}
	 */
	protected void sequence_ProcessChainGoTo(EObject context, ProcessChainGoToPrevious semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (processChainStep=[ProcessChainStep|QUALIFIED_NAME] returnTo=[ProcessChainStep|QUALIFIED_NAME]?)
	 */
	protected void sequence_ProcessChainGoTo(EObject context, ProcessChainGoToStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((changeStep?='and' (changeDirection='proceed' | changeDirection='reverse'))?)
	 */
	protected void sequence_ProcessChainGoTo(EObject context, ProcessChainReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID view=AbstractViewGUIElementRef gotos+=ProcessChainGoToDefinition* message=SimpleExpression?)
	 */
	protected void sequence_ProcessChainStep(EObject context, ProcessChainStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID processChainSteps+=ProcessChainStep*)
	 */
	protected void sequence_ProcessChain(EObject context, ProcessChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (key=STRING value=RESTValue)
	 */
	protected void sequence_RESTParam(EObject context, RESTParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getRESTParam_Key()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getRESTParam_Key()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getRESTParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getRESTParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRESTParamAccess().getKeySTRINGTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getRESTParamAccess().getValueRESTValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_RESTValue(EObject context, BooleanRestParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getBooleanRestParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getBooleanRestParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRESTValueAccess().getValueBooleanEnumRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=ContentProviderPath
	 */
	protected void sequence_RESTValue(EObject context, ContentProviderRestParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getContentProviderRestParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getContentProviderRestParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRESTValueAccess().getValueContentProviderPathParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_RESTValue(EObject context, FloatRestParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getFloatRestParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getFloatRestParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRESTValueAccess().getValueFLOATParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_RESTValue(EObject context, IntegerRestParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getIntegerRestParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getIntegerRestParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRESTValueAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_RESTValue(EObject context, StringRestParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getStringRestParam_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getStringRestParam_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRESTValueAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ReferencedTypeParam(EObject context, AttrEnumDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrEnumDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrEnumDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReferencedTypeParamAccess().getValueSTRINGTerminalRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_ReferencedTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReferencedTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     regEx=STRING
	 */
	protected void sequence_RegExValidatorParam(EObject context, ValidatorRegExParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorRegExParam_RegEx()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorRegExParam_RegEx()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRegExValidatorParamAccess().getRegExSTRINGTerminalRuleCall_1_2_0(), semanticObject.getRegEx());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         uri=STRING 
	 *         password=STRING? 
	 *         user=STRING? 
	 *         key=STRING? 
	 *         storagePath=STRING?
	 *     )
	 */
	protected void sequence_RemoteConnection(EObject context, RemoteConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         params+=ValidatorMessageParam? 
	 *         connection=[RemoteConnection|ID]? 
	 *         (contentProvider=ContentProviderReference | provideAttributes+=ContentProviderPath+)
	 *     )
	 */
	protected void sequence_RemoteValidator(EObject context, RemoteValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     contentProvider=ContentProviderReference
	 */
	protected void sequence_SimpleAction(EObject context, ContentProviderAddAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (contentProvider=AbstractProviderReference whereClause=WhereClauseCondition?)
	 */
	protected void sequence_SimpleAction(EObject context, ContentProviderGetAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operation=AllowedOperation contentProvider=AbstractProviderReference)
	 */
	protected void sequence_SimpleAction(EObject context, ContentProviderOperationAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (contentProvider=ContentProviderReference whereClause=WhereClauseCondition)
	 */
	protected void sequence_SimpleAction(EObject context, ContentProviderRemoveAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     contentProvider=ContentProviderReference
	 */
	protected void sequence_SimpleAction(EObject context, ContentProviderResetAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     inputField=AbstractViewGUIElementRef
	 */
	protected void sequence_SimpleAction(EObject context, DisableAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     message=SimpleExpression
	 */
	protected void sequence_SimpleAction(EObject context, DisplayMessageAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     inputField=AbstractViewGUIElementRef
	 */
	protected void sequence_SimpleAction(EObject context, EnableAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     workflowEvent=WorkflowEvent
	 */
	protected void sequence_SimpleAction(EObject context, FireEventAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     view=AbstractViewGUIElementRef
	 */
	protected void sequence_SimpleAction(EObject context, GotoViewAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         cityInput=AbstractContentProviderPath 
	 *         streetInput=AbstractContentProviderPath 
	 *         streetNumberInput=AbstractContentProviderPath? 
	 *         postalInput=AbstractContentProviderPath 
	 *         countryInput=AbstractContentProviderPath 
	 *         latitude=AbstractContentProviderPath 
	 *         longitude=AbstractContentProviderPath
	 *     )
	 */
	protected void sequence_SimpleAction(EObject context, LocationAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     pcStep=[ProcessChainStep|QUALIFIED_NAME]
	 */
	protected void sequence_SimpleAction(EObject context, ProcessChainGotoAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ProcessChainProceedAction}
	 */
	protected void sequence_SimpleAction(EObject context, ProcessChainProceedAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ProcessChainReverseAction}
	 */
	protected void sequence_SimpleAction(EObject context, ProcessChainReverseAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     processChain=[ProcessChain|ID]
	 */
	protected void sequence_SimpleAction(EObject context, SetProcessChainAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     webServiceCall=[WebServiceCall|ID]
	 */
	protected void sequence_SimpleAction(EObject context, WebServiceCallAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=SimpleDataType
	 */
	protected void sequence_SimpleDataTypeWrapper(EObject context, SimpleDataTypeWrapper semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getSimpleDataTypeWrapper_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getSimpleDataTypeWrapper_Type()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSimpleDataTypeWrapperAccess().getTypeSimpleDataTypeEnumRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (number=INT? width=PERCENT?)
	 */
	protected void sequence_Spacer(EObject context, Spacer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=DateRangeValidatorParam params+=DateRangeValidatorParam*)
	 */
	protected void sequence_StandardValidator(EObject context, StandardDateRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=DateTimeRangeValidatorParam params+=DateTimeRangeValidatorParam*)
	 */
	protected void sequence_StandardValidator(EObject context, StandardDateTimeRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=ValidatorMessageParam?)
	 */
	protected void sequence_StandardValidator(EObject context, StandardNotNullValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=NumberRangeValidatorParam params+=NumberRangeValidatorParam*)
	 */
	protected void sequence_StandardValidator(EObject context, StandardNumberRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=RegExValidatorParam params+=RegExValidatorParam*)
	 */
	protected void sequence_StandardValidator(EObject context, StandardRegExValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=StringRangeValidatorParam params+=StringRangeValidatorParam*)
	 */
	protected void sequence_StandardValidator(EObject context, StandardStringRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (params+=TimeRangeValidatorParam params+=TimeRangeValidatorParam*)
	 */
	protected void sequence_StandardValidator(EObject context, StandardTimeRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_StringPartial(EObject context, BooleanVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getBooleanVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getBooleanVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringPartialAccess().getValueBooleanEnumRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=DATE_TIME
	 */
	protected void sequence_StringPartial(EObject context, DateTimeVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getDateTimeVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getDateTimeVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringPartialAccess().getValueDATE_TIMEParserRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=DATE
	 */
	protected void sequence_StringPartial(EObject context, DateVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getDateVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getDateVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringPartialAccess().getValueDATEParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringPartial(EObject context, StringVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getStringVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getStringVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringPartialAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=TIME
	 */
	protected void sequence_StringPartial(EObject context, TimeVal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getTimeVal_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getTimeVal_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringPartialAccess().getValueTIMEParserRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     maxLength=INT
	 */
	protected void sequence_StringRangeValidatorParam(EObject context, ValidatorMaxLengthParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMaxLengthParam_MaxLength()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMaxLengthParam_MaxLength()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringRangeValidatorParamAccess().getMaxLengthINTTerminalRuleCall_1_2_0(), semanticObject.getMaxLength());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     minLength=INT
	 */
	protected void sequence_StringRangeValidatorParam(EObject context, ValidatorMinLengthParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMinLengthParam_MinLength()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMinLengthParam_MinLength()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringRangeValidatorParamAccess().getMinLengthINTTerminalRuleCall_2_2_0(), semanticObject.getMinLength());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     identifier?='identifier'
	 */
	protected void sequence_StringTypeParam(EObject context, AttrIdentifier semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIdentifier_Identifier()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIdentifier_Identifier()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringTypeParamAccess().getIdentifierIdentifierKeyword_1_1_0(), semanticObject.isIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_StringTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringTypeParam(EObject context, AttrStringDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrStringDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrStringDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringTypeParamAccess().getValueSTRINGTerminalRuleCall_2_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     max=INT
	 */
	protected void sequence_StringTypeParam(EObject context, AttrStringMax semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrStringMax_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrStringMax_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringTypeParamAccess().getMaxINTTerminalRuleCall_3_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=INT
	 */
	protected void sequence_StringTypeParam(EObject context, AttrStringMin semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrStringMin_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrStringMin_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringTypeParamAccess().getMinINTTerminalRuleCall_4_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     definition=StyleBody
	 */
	protected void sequence_StyleAssignment(EObject context, StyleDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getStyleDefinition_Definition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getStyleDefinition_Definition()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStyleAssignmentAccess().getDefinitionStyleBodyParserRuleCall_0_1_0(), semanticObject.getDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     reference=[Style|ID]
	 */
	protected void sequence_StyleAssignment(EObject context, StyleReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getStyleReference_Reference()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getStyleReference_Reference()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStyleAssignmentAccess().getReferenceStyleIDTerminalRuleCall_1_1_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (fontSize=FLOAT? color=Color? (bold?='bold'? italic?='italic'?)?)
	 */
	protected void sequence_StyleBody(EObject context, StyleBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID body=StyleBody)
	 */
	protected void sequence_Style(EObject context, Style semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getViewElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getViewElement_Name()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getStyle_Body()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getStyle_Body()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStyleAccess().getNameEIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStyleAccess().getBodyStyleBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     tabIcon=STRING
	 */
	protected void sequence_TabSpecificParam(EObject context, TabIconParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getTabIconParam_TabIcon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getTabIconParam_TabIcon()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTabSpecificParamAccess().getTabIconSTRINGTerminalRuleCall_1_2_0(), semanticObject.getTabIcon());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     tabTitle=STRING
	 */
	protected void sequence_TabSpecificParam(EObject context, TabTitleParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getTabTitleParam_TabTitle()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getTabTitleParam_TabTitle()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTabSpecificParamAccess().getTabTitleSTRINGTerminalRuleCall_0_2_0(), semanticObject.getTabTitle());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID elements+=ContainerElementType*)
	 */
	protected void sequence_TabbedAlternativesPane(EObject context, TabbedAlternativesPane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=TextInputType? 
	 *             isDisabled?='true'? 
	 *             defaultValue=STRING? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_TextInput(EObject context, TextInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         (
	 *             labelText=STRING? 
	 *             tooltipText=STRING? 
	 *             type=TimeInputType? 
	 *             isDisabled?='true'? 
	 *             defaultValue=TIME? 
	 *             width=PERCENT?
	 *         )?
	 *     )
	 */
	protected void sequence_TimeInput(EObject context, TimeInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     max=TIME
	 */
	protected void sequence_TimeRangeValidatorParam(EObject context, ValidatorMaxTimeParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMaxTimeParam_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMaxTimeParam_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeRangeValidatorParamAccess().getMaxTIMEParserRuleCall_1_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=TIME
	 */
	protected void sequence_TimeRangeValidatorParam(EObject context, ValidatorMinTimeParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMinTimeParam_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMinTimeParam_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeRangeValidatorParamAccess().getMinTIMEParserRuleCall_2_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     optional?='optional'
	 */
	protected void sequence_TimeTypeParam(EObject context, AttrIsOptional semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrIsOptional_Optional()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeTypeParamAccess().getOptionalOptionalKeyword_0_1_0(), semanticObject.isOptional());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=TIME
	 */
	protected void sequence_TimeTypeParam(EObject context, AttrTimeDefault semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrTimeDefault_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrTimeDefault_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeTypeParamAccess().getValueTIMEParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     max=TIME
	 */
	protected void sequence_TimeTypeParam(EObject context, AttrTimeMax semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrTimeMax_Max()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrTimeMax_Max()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeTypeParamAccess().getMaxTIMEParserRuleCall_2_2_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     min=TIME
	 */
	protected void sequence_TimeTypeParam(EObject context, AttrTimeMin semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getAttrTimeMin_Min()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getAttrTimeMin_Min()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeTypeParamAccess().getMinTIMEParserRuleCall_3_2_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID text=STRING width=PERCENT?)
	 */
	protected void sequence_TooltipExtendedDefinition(EObject context, Tooltip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID text=STRING width=PERCENT?)
	 */
	protected void sequence_TooltipShorthandDefinition(EObject context, Tooltip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=EID text=STRING width=PERCENT?) | (name=EID text=STRING width=PERCENT?))
	 */
	protected void sequence_Tooltip_TooltipExtendedDefinition_TooltipShorthandDefinition(EObject context, Tooltip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID (imgHeight=INT? imgWidth=INT? width=INT?)?)
	 */
	protected void sequence_UploadedImageOutput(EObject context, UploadedImageOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     message=SimpleExpression
	 */
	protected void sequence_ValidatorMessageParam(EObject context, ValidatorMessageParam semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getValidatorMessageParam_Message()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getValidatorMessageParam_Message()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValidatorMessageParamAccess().getMessageSimpleExpressionParserRuleCall_1_0(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     validator=[Validator|QUALIFIED_NAME]
	 */
	protected void sequence_ValidatorType(EObject context, CustomizedValidatorType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getCustomizedValidatorType_Validator()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getCustomizedValidatorType_Validator()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValidatorTypeAccess().getValidatorValidatorQUALIFIED_NAMEParserRuleCall_0_1_0_1(), semanticObject.getValidator());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     validator=StandardValidator
	 */
	protected void sequence_ValidatorType(EObject context, StandardValidatorType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getStandardValidatorType_Validator()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getStandardValidatorType_Validator()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValidatorTypeAccess().getValidatorStandardValidatorParserRuleCall_1_1_0(), semanticObject.getValidator());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=DateRangeValidatorParam params+=DateRangeValidatorParam*)
	 */
	protected void sequence_Validator(EObject context, DateRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=DateTimeRangeValidatorParam params+=DateTimeRangeValidatorParam*)
	 */
	protected void sequence_Validator(EObject context, DateTimeRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=ValidatorMessageParam?)
	 */
	protected void sequence_Validator(EObject context, NotNullValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=NumberRangeValidatorParam params+=NumberRangeValidatorParam*)
	 */
	protected void sequence_Validator(EObject context, NumberRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=RegExValidatorParam params+=RegExValidatorParam*)
	 */
	protected void sequence_Validator(EObject context, RegExValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=StringRangeValidatorParam params+=StringRangeValidatorParam*)
	 */
	protected void sequence_Validator(EObject context, StringRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID params+=TimeRangeValidatorParam params+=TimeRangeValidatorParam*)
	 */
	protected void sequence_Validator(EObject context, TimeRangeValidator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=[ViewGUIElement|QUALIFIED_NAME] (rename?='->' name=EID)?)
	 */
	protected void sequence_ViewGUIElementReference(EObject context, ViewGUIElementReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     viewElements+=ViewElement+
	 */
	protected void sequence_View(EObject context, View semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EID url=STRING method=RESTMethod queryparams+=RESTParam* bodyparams+=RESTParam*)
	 */
	protected void sequence_WebServiceCall(EObject context, WebServiceCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpression=WhereClauseAnd_WhereClauseAnd_1_0 rightExpression=WhereClauseConditionalExpression)
	 */
	protected void sequence_WhereClauseAnd(EObject context, WhereClauseAnd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseAnd_LeftExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseAnd_LeftExpression()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseAnd_RightExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseAnd_RightExpression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhereClauseAndAccess().getWhereClauseAndLeftExpressionAction_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getWhereClauseAndAccess().getRightExpressionWhereClauseConditionalExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (eqLeft=EntityPath op=Operator eqRight=SimpleExpression)
	 */
	protected void sequence_WhereClauseConditionalExpression(EObject context, WhereClauseCompareExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseCompareExpression_EqLeft()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseCompareExpression_EqLeft()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseCompareExpression_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseCompareExpression_Op()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseCompareExpression_EqRight()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseCompareExpression_EqRight()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhereClauseConditionalExpressionAccess().getEqLeftEntityPathParserRuleCall_2_1_0(), semanticObject.getEqLeft());
		feeder.accept(grammarAccess.getWhereClauseConditionalExpressionAccess().getOpOperatorEnumRuleCall_2_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getWhereClauseConditionalExpressionAccess().getEqRightSimpleExpressionParserRuleCall_2_3_0(), semanticObject.getEqRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=WhereClauseConditionalExpression
	 */
	protected void sequence_WhereClauseConditionalExpression(EObject context, WhereClauseNot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseNot_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseNot_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhereClauseConditionalExpressionAccess().getExpressionWhereClauseConditionalExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpression=WhereClauseOr_WhereClauseOr_1_0 rightExpression=WhereClauseAnd)
	 */
	protected void sequence_WhereClauseOr(EObject context, WhereClauseOr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseOr_LeftExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseOr_LeftExpression()));
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWhereClauseOr_RightExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWhereClauseOr_RightExpression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhereClauseOrAccess().getWhereClauseOrLeftExpressionAction_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getWhereClauseOrAccess().getRightExpressionWhereClauseAndParserRuleCall_1_2_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (workflowElement=[WorkflowElement|ID] (invokable?='invokable' eventDesc=STRING?)? firedEvents+=FireEventEntry+)
	 */
	protected void sequence_WorkflowElementEntry(EObject context, WorkflowElementEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (workflowElementReference=[WorkflowElement|ID] (startable?='startable:' alias=STRING)?)
	 */
	protected void sequence_WorkflowElementReference(EObject context, WorkflowElementReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EID 
	 *         defaultProcessChain=[ProcessChain|ID] 
	 *         initActions+=[Action|ID] 
	 *         initActions+=[Action|ID]* 
	 *         actions+=Action* 
	 *         processChain+=ProcessChain+ 
	 *         invoke+=InvokeDefinition*
	 *     )
	 */
	protected void sequence_WorkflowElement(EObject context, WorkflowElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=EID
	 */
	protected void sequence_WorkflowEvent(EObject context, WorkflowEvent semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MD2Package.eINSTANCE.getWorkflowEvent_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MD2Package.eINSTANCE.getWorkflowEvent_Name()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWorkflowEventAccess().getNameEIDParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (workflowElementEntries+=WorkflowElementEntry+ apps+=App+)
	 */
	protected void sequence_Workflow(EObject context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
